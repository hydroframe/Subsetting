<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>parflow.tools.builders API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parflow.tools.builders</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># builders.py
# functions for helping build ParFlow scripts
import os
import yaml
import sys
import numpy as np

from .helper import sort_dict
from .fs import exists

try:
    from yaml import CDumper as YAMLDumper
except ImportError:
    from yaml import Dumper as YAMLDumper

from parflow.tools.io import write_patch_matrix_as_asc
from parflow.tools.fs import get_absolute_path


class NoAliasDumper(yaml.SafeDumper):

    def ignore_aliases(self, data):
        &#34;&#34;&#34;addressing alias printing when applying database properties
        to multiple keys
        &#34;&#34;&#34;
        return True


class SolidFileBuilder:

    def __init__(self, top=1, bottom=2, side=3):
        self.name = None
        self.mask_array = None
        self.patch_ids_top = None
        self.patch_ids_bottom = None
        self.patch_ids_side = None
        self.top_id = top
        self.bottom_id = bottom
        self.side_id = side

    def mask(self, mask_array):
        &#34;&#34;&#34;Setting mask array to SolidFileBuilder object

        Args:
            mask_array (array): Array of values to define the mask.
        &#34;&#34;&#34;
        self.mask_array = mask_array
        return self

    def top(self, patch_id):
        &#34;&#34;&#34;Overwriting top patch ID

        Args:
            patch_id (int): ID of top patch in mask array
        &#34;&#34;&#34;
        self.top_id = patch_id
        self.patch_ids_top = None
        return self

    def bottom(self, patch_id):
        &#34;&#34;&#34;Overwriting bottom patch ID

        Args:
            patch_id (int): ID of bottom patch in mask array
        &#34;&#34;&#34;
        self.bottom_id = patch_id
        self.patch_ids_top = None
        return self

    def side(self, patch_id):
        &#34;&#34;&#34;Overwriting side patch ID

        Args:
            patch_id (int): ID of side patch in mask array
        &#34;&#34;&#34;
        self.side_id = patch_id
        self.patch_ids_side = None
        return self

    def top_ids(self, top_patch_ids):
        &#34;&#34;&#34;Overwriting top patch ID with multiple IDs

        Args:
            top_patch_ids (array): array of top patch ids
        &#34;&#34;&#34;
        self.patch_ids_top = top_patch_ids
        return self

    def bottom_ids(self, bottom_patch_ids):
        &#34;&#34;&#34;Overwriting bottom patch ID with multiple IDs

        Args:
            bottom_patch_ids (array): array of bottom patch ids
        &#34;&#34;&#34;
        self.patch_ids_bottom = bottom_patch_ids
        return self

    def side_ids(self, side_patch_ids):
        &#34;&#34;&#34;Overwriting side patch ID with multiple IDs

        Args:
            side_patch_ids (array): array of side patch ids
        &#34;&#34;&#34;
        self.patch_ids_side = side_patch_ids
        return self

    def write(self, name, xllcorner=0, yllcorner=0, cellsize=0, vtk=False):
        &#34;&#34;&#34;Writing out pfsol file with optional output to vtk

        Args:
            name (str): Name of solid file to write
            xllcorner (int, float): coordinate of lower-left corner of x-axis
            yllcorner (int, float): coordinate of lower-left corner of y-axis
            cellsize (int): size of horizontal grid cell for solid file
        &#34;&#34;&#34;
        self.name = name
        output_file_path = get_absolute_path(name)
        if self.mask_array is None:
            raise Exception(&#39;No mask was defined&#39;)

        jSize, iSize = self.mask_array.shape
        leftMask = np.zeros((jSize, iSize), dtype=np.int16)
        rightMask = np.zeros((jSize, iSize), dtype=np.int16)
        backMask = np.zeros((jSize, iSize), dtype=np.int16)
        frontMask = np.zeros((jSize, iSize), dtype=np.int16)
        bottomMask = np.zeros((jSize, iSize), dtype=np.int16)
        topMask = np.zeros((jSize, iSize), dtype=np.int16)

        for j in range(jSize):
            for i in range(iSize):
                if self.mask_array[j, i] != 0:
                    patch_value = 0 if self.patch_ids_side is None \
                        else self.patch_ids_side[j, i]
                    # Left (-x)
                    if i == 0 or self.mask_array[j, i-1] == 0:
                        leftMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Right (+x)
                    if i + 1 == iSize or self.mask_array[j, i+1] == 0:
                        rightMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Back (-y) (y flipped)
                    if j + 1 == jSize or self.mask_array[j+1, i] == 0:
                        backMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Front (+y) (y flipped)
                    if j == 0 or self.mask_array[j-1, i] == 0:
                        frontMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Bottom (-z)
                    patch_value = 0 if self.patch_ids_bottom is None \
                        else self.patch_ids_bottom[j, i]
                    bottomMask[j, i] = patch_value if patch_value \
                        else self.bottom_id

                    # Top (+z)
                    patch_value = 0 if self.patch_ids_top is None \
                        else self.patch_ids_top[j, i]
                    topMask[j, i] = patch_value if patch_value \
                        else self.top_id

        # Generate asc / sa files
        writeFn = write_patch_matrix_as_asc
        settings = {
            &#39;xllcorner&#39;: xllcorner,
            &#39;yllcorner&#39;: yllcorner,
            &#39;cellsize&#39;: cellsize,
            &#39;NODATA_value&#39;: 0,
        }
        short_name = name[:-6]

        left_file_path = get_absolute_path(f&#39;{short_name}_left.asc&#39;)
        writeFn(leftMask, left_file_path, **settings)

        right_file_path = get_absolute_path(f&#39;{short_name}_right.asc&#39;)
        writeFn(rightMask, right_file_path, **settings)

        front_file_path = get_absolute_path(f&#39;{short_name}_front.asc&#39;)
        writeFn(frontMask, front_file_path, **settings)

        back_file_path = get_absolute_path(f&#39;{short_name}_back.asc&#39;)
        writeFn(backMask, back_file_path, **settings)

        top_file_path = get_absolute_path(f&#39;{short_name}_top.asc&#39;)
        writeFn(topMask, top_file_path, **settings)

        bottom_file_path = get_absolute_path(f&#39;{short_name}_bottom.asc&#39;)
        writeFn(bottomMask, bottom_file_path, **settings)

        # Trigger conversion
        print(&#39;=== pfmask-to-pfsol ===: BEGIN&#39;)
        extra = []
        if vtk:
            extra.append(&#39;--vtk&#39;)
            extra.append(f&#39;{output_file_path[:-6]}.vtk&#39;)
        os.system(f&#39;$PARFLOW_DIR/bin/pfmask-to-pfsol &#39;
                  f&#39;--mask-top {top_file_path} &#39;
                  f&#39;--mask-bottom {bottom_file_path} &#39;
                  f&#39;--mask-left {left_file_path} &#39;
                  f&#39;--mask-right {right_file_path} &#39;
                  f&#39;--mask-front {front_file_path} &#39;
                  f&#39;--mask-back {back_file_path} &#39;
                  f&#39;--pfsol {output_file_path} {&#34; &#34;.join(extra)}&#39;)
        print(&#39;=== pfmask-to-pfsol ===: END&#39;)
        return self

    def for_key(self, geomItem):
        &#34;&#34;&#34;Setting ParFlow keys associated with solid file

        Args:
            geomItem (str): Name of geometric unit in ParFlow run that will
            bet used as a token for the ParFlow key.
        &#34;&#34;&#34;
        geomItem.InputType = &#39;SolidFile&#39;
        geomItem.FileName = self.name
        return self

# -----------------------------------------------------------------------------
# Subsurface hydraulic property input helper
# -----------------------------------------------------------------------------


# splitting csv and txt lines into tokens
def _csv_line_tokenizer(line):
    return [token.strip() for token in line.split(&#39;,&#39;)]


def _txt_line_tokenizer(line):
    return line.split()


class SubsurfacePropertiesBuilder:

    def __init__(self, run=None):
        if run is not None:
            self.run = run
        self.output = {}
        self.name_registration = {}
        self.column_index = {}
        self.props_in_row_header = True
        self.table_comments = []
        yaml_key_def = os.path.join(
            os.path.dirname(__file__), &#39;ref/table_keys.yaml&#39;)
        with open(yaml_key_def, &#39;r&#39;) as file:
            self.definition = yaml.safe_load(file)

        # Extract prop column names
        self.prop_names = []
        self.alias_to_pfkey = {}
        self.pfkey_to_alias = {}
        self.alias_duplicates = set()
        for key, value in self.definition.items():
            self.pfkey_to_alias[key] = value[&#39;alias&#39;][0]
            for alias in value[&#39;alias&#39;]:
                # checking for duplicate aliases
                if alias in self.prop_names:
                    self.alias_duplicates.add(alias)

                self.prop_names.append(alias)
                self.alias_to_pfkey[alias] = key

        # crashes if there are duplicate aliases
        if self.alias_duplicates:
            raise Exception(f&#39;Warning - duplicate alias name(s):&#39;
                            f&#39; {self.alias_duplicates}&#39;)

    def _process_data_line(self, tokens):
        &#34;&#34;&#34;Method to process lines of data in a table
        &#34;&#34;&#34;
        # Skip new lines or comments
        if len(tokens) == 0 or tokens[0] == &#39;#&#39;:
            return

        if self.props_in_row_header:
            # Key column contains geom_name
            data = {}
            registrations = []
            for alias, col_idx in self.column_index.items():
                str_value = tokens[col_idx]
                if str_value == &#39;-&#39;:
                    continue

                key = self.alias_to_pfkey[alias]
                key_def = self.definition[key]
                value_type = key_def.get(&#39;type&#39;, &#39;float&#39;)
                value = __builtins__[value_type](str_value)
                data[key] = value

                # setting related addon keys
                if &#39;addon&#39; in key_def.keys():
                    for key, value in key_def[&#39;addon&#39;].items():
                        # local keys (appending to geom item)
                        if key[0] == &#39;.&#39;:
                            data.update({key[1:]: value})
                        # global keys
                        elif key not in self.output:
                            self.output.update({key: value})

                # appending geom name to list for setting geom name keys
                if &#39;register&#39; in key_def.keys():
                    registrations.append(key_def[&#39;register&#39;])

            # Extract geom_name
            geom_name = data[&#39;key&#39;]
            del data[&#39;key&#39;]
            self.output[geom_name] = data

            if not hasattr(self.name_registration, geom_name):
                self.name_registration[geom_name] = set()

            self.name_registration[geom_name].update(registrations)

        else:
            # Key column contains property values
            data = {}
            registrations = []

            main_key = &#39;key&#39;
            for key_alias in self.column_index:
                if key_alias in self.definition[&#39;key&#39;][&#39;alias&#39;]:
                    main_key = key_alias

            prop_alias = tokens[self.column_index[main_key]]
            key = self.alias_to_pfkey[prop_alias]
            key_def = self.definition[key]
            value_type = key_def.get(&#39;type&#39;, &#39;float&#39;)
            value_convert = __builtins__[value_type]
            # setting related addon keys
            if &#39;addon&#39; in key_def.keys():
                for addon_key, addon_value in key_def[&#39;addon&#39;].items():
                    # local keys (appending to geom item)
                    if addon_key[0] == &#39;.&#39;:
                        data.update({addon_key[1:]: addon_value})
                    # global keys
                    elif addon_key not in self.output:
                        self.output.update({addon_key: addon_value})

            # appending geom name to list for setting geom name keys
            if &#39;register&#39; in key_def.keys():
                registrations.append(key_def[&#39;register&#39;])

            for geom_name in self.column_index:
                if geom_name == main_key:
                    continue

                container = self.output[geom_name]
                value_str = tokens[self.column_index[geom_name]]
                if value_str == &#39;-&#39;:
                    continue

                value = value_convert(value_str)
                container[key] = value
                container.update(data)
                if registrations:
                    self.name_registration[geom_name].update(registrations)

    def _process_first_line(self, first_line_tokens):
        &#34;&#34;&#34;Method to process first line in a table
        &#34;&#34;&#34;
        # Skip new lines or comments
        if len(first_line_tokens) == 0:
            return False
        if first_line_tokens[0] == &#39;#&#39;:
            self.table_comments.append(&#34; &#34;.join(first_line_tokens))
            return False

        self.props_in_row_header = None
        found = []
        not_found = []
        index = 0
        for token in first_line_tokens:
            self.column_index[token] = index
            index += 1

            if token in self.alias_to_pfkey:
                found.append(token)
            else:
                not_found.append(token)

        if len(not_found) == 0:
            self.props_in_row_header = True
        elif len(found) &gt; 1 and len(not_found) &gt; 1:
            print(&#39;Error while processing input table:&#39;)
            print(f&#39; - Properties found: {found}&#39;)
            print(f&#39; - Properties not found: {not_found}&#39;)
        elif len(found) == 1:
            self.props_in_row_header = False
            # Prefill geo_name containers
            for geom_name in self.column_index:
                if geom_name not in self.definition[&#39;key&#39;][&#39;alias&#39;]:
                    self.output[geom_name] = {}
                    self.name_registration[geom_name] = set()

        if self.props_in_row_header is None:
            raise Exception(&#39;Invalid table format&#39;)

        return True

    def load_csv_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
        &#34;&#34;&#34;Method to load a .csv file of a table of subsurface parameters

        Args:
            tableFile (str): Path to the input .csv file.
            encoding=&#39;utf-8-sig&#39;: encoding of input file.
        &#34;&#34;&#34;
        with open(get_absolute_path(tableFile), &#39;r&#39;,
                  encoding=encoding) as csv_file:
            data_line = False
            for line in csv_file:
                tokens = _csv_line_tokenizer(line)
                if data_line:
                    self._process_data_line(tokens)
                else:
                    data_line = self._process_first_line(tokens)
        return self

    def load_txt_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
        &#34;&#34;&#34;Method to load a .txt file of a table of subsurface parameters

        Args:
            tableFile (str): Path to the input .txt file.
            encoding=&#39;utf-8-sig&#39;: encoding of input file.
        &#34;&#34;&#34;
        with open(get_absolute_path(tableFile), &#39;r&#39;,
                  encoding=encoding) as txt_file:
            data_line = False
            for line in txt_file:
                tokens = _txt_line_tokenizer(line)
                if data_line:
                    self._process_data_line(tokens)
                else:
                    data_line = self._process_first_line(tokens)

        return self

    def load_txt_content(self, txt_content):
        &#34;&#34;&#34;Method to load an in-line text table of subsurface parameters

        Args:
            txt_content (str): In-line text string.
        &#34;&#34;&#34;
        data_line = False
        for line in txt_content.splitlines():
            tokens = _txt_line_tokenizer(line)
            if data_line:
                self._process_data_line(tokens)
            else:
                data_line = self._process_first_line(tokens)

        return self

    def assign(self, old=None, new=None, mapping=None):
        &#34;&#34;&#34;Method to assigning subsurface properties of one unit to another

        Args:
            old=None (str): Source unit with existing parameters
            new=None (str): Target unit to which the parameters
                            from old will be mapped
            mapping=None (dict): Dictionary that includes the old units as keys
                and new units as values.
        &#34;&#34;&#34;
        # assigning subsurface properties of one unit to another
        if isinstance(new, list):
            for item in new:
                self.assign(old, item)

        elif old != new:
            data = self.output[old]
            self.output[new] = data

        if mapping is not None:
            for old, new in mapping.items():
                self.assign(old, new)

        return self

    def load_default_properties(self, database=&#39;conus_1&#39;):
        &#34;&#34;&#34;Method to load one of several default property databases.

        Args:
           database=&#39;conus_1&#39;: default database - options are:
           &#39;conus_1&#39;: soil/rock properties from Maxwell and Condon (2016)
           &#39;washita&#39;: soil/rock properties from Little Washita script
           &#39;freeze_cherry&#39;: soil/rock properties from Freeze and Cherry (1979)
           Note: Freeze and Cherry only has permeability and porosity
        &#34;&#34;&#34;
        database_file = &#39;ref/subsurface_&#39; + database + &#39;.txt&#39;

        default_prop_file = os.path.join(
            os.path.dirname(__file__), database_file)

        if exists(default_prop_file):
            self.load_txt_file(default_prop_file)
            print(&#39;#&#39;*80)
            print(&#39;# Loaded database:&#39;)
            for item in self.table_comments:
                print(item)
            print(&#39;#&#39; * 80)
        else:
            print(&#39;#&#39; * 80)
            print(f&#39;# {database} database not found. Available databases include:&#39;)
            for root, dirs, files in os.walk(os.path.dirname(__file__) + &#39;/ref/&#39;):
                for name in files:
                    if name.startswith(&#39;subsurface&#39;):
                        print(f&#39;# - {name} (use argument &#39;
                              f&#39;&#34;{name[len(&#34;subsurface_&#34;):-len(&#34;.txt&#34;)]}&#34;)&#39;)
            print(&#39;#&#39; * 80)


        return self

    def apply(self, run=None, name_registration=True):
        &#34;&#34;&#34;Method to apply the loaded subsurface properties to a given
           run object.

        Args:
            run=None (Run object): Run object to which the loaded subsurface
                parameters will be applied. If run=None, then the run object
                must be passed in as an argument when the
                SubsurfacePropertiesBuilder is instantiated.
            name_registration=True (bool): sets the auxiliary keys
                (e.g., GeomNames) related to the loaded subsurface properties
        &#34;&#34;&#34;
        # applying subsurface properties to run keys
        if run is None:
            if self.run is None:
                print(&#39;No run object assigned&#39;)
                sys.exit(1)
        else:
            self.run = run

        valid_geom_names = []
        addon_keys = {}
        for name in self.output:
            if name in self.run.Geom.__dict__.keys():
                valid_geom_names.append(name)
            elif name_registration and type(self.output[name]) is not dict:
                addon_keys[name] = self.output[name]

        # Run pfset on all geom sections
        for geom_name in valid_geom_names:
            self.run.Geom[geom_name].pfset(flat_map=self.output[geom_name])

        # Handle names
        if name_registration:
            names_to_set = addon_keys
            for geom_name in valid_geom_names:
                if geom_name in self.name_registration.keys():
                    for prop_name in self.name_registration[geom_name]:
                        if prop_name not in names_to_set.keys():
                            names_to_set[prop_name] = []
                        names_to_set[prop_name].append(geom_name)
            self.run.pfset(flat_map=names_to_set)

        return self

    def print(self):
        &#34;&#34;&#34;Method to print subsurface properties in hierarchical format
        &#34;&#34;&#34;
        output_to_print = {&#39;Geom&#39;: {}}
        valid_geom_names = []
        for geom_name in self.output:
            if hasattr(self.run.Geom, geom_name):
                valid_geom_names.append(geom_name)

        for geom_name in valid_geom_names:
            if hasattr(self.name_registration, geom_name):
                for prop_name in self.name_registration[geom_name]:
                    if not hasattr(output_to_print, prop_name):
                        output_to_print[prop_name] = []
                    output_to_print[prop_name].append(geom_name)

        for geom_name in valid_geom_names:
            output_to_print[&#39;Geom&#39;][geom_name] = self.output[geom_name]

        print(yaml.dump(sort_dict(output_to_print), Dumper=NoAliasDumper))
        return self

    def get_table(self, props_in_header=True, column_separator=&#39;  &#39;):
        &#34;&#34;&#34;Method to convert loaded subsurface properties into a table

        Args:
            props_in_header=True (bool): Defaults to returning a table with
                property values at the top of each column
            column_separator=&#39;  &#39; (str): Defaults to returning a table that
                is space-delimited.

        Returns:
            text block of table of subsurface units and parameter values
        &#34;&#34;&#34;
        entries = []
        prop_set = set()
        prop_sizes = {&#39;key&#39;: 0}
        geom_sizes = {&#39;key&#39;: 0}

        # Fill entries headers
        for geo_name, props in self.output.items():
            if not isinstance(props, dict):
                continue
            elif not hasattr(self.run.Geom, geo_name):
                continue

            entry = {
                &#39;key&#39;: geo_name,
            }
            prop_sizes[&#39;key&#39;] = max(prop_sizes[&#39;key&#39;], len(geo_name))
            geom_sizes[geo_name] = len(geo_name)
            for prop in props:
                if prop in self.pfkey_to_alias:
                    alias = self.pfkey_to_alias[prop]
                    value = str(props[prop])
                    size = len(value)
                    entry[alias] = value
                    prop_set.add(alias)

                    # Find bigger size for geom
                    geom_sizes[geo_name] = max(geom_sizes[geo_name], size)

                    # Find bigger size for props
                    if alias not in prop_sizes:
                        prop_sizes[alias] = max(size, len(alias))
                    else:
                        prop_sizes[alias] = max(prop_sizes[alias], size)

                    geom_sizes[&#39;key&#39;] = max(geom_sizes[&#39;key&#39;], len(alias))

            entries.append(entry)

        # Figure out orientation
        prop_header_width = 0
        for alias in prop_sizes:
            prop_header_width += prop_sizes[alias] + 2

        geom_header_width = 0
        for geom_name in geom_sizes:
            geom_header_width += geom_sizes[geom_name] + 2

        # Build table
        table_lines = []
        header_keys = []
        if props_in_header:
            sizes = prop_sizes
            # Create table using props as header
            line = []
            for prop in sizes:
                header_keys.append(prop)
                width = sizes[prop]
                line.append(prop.ljust(width))

            # Add header
            table_lines.append(column_separator.join(line))

            # Add content
            for entry in entries:
                line = []
                for key in header_keys:
                    value = entry[key] if key in entry else &#39;-&#39;
                    width = sizes[key]
                    line.append(value.ljust(width))
                table_lines.append(column_separator.join(line))

        else:
            sizes = geom_sizes
            # Create table using geom name as header
            line = []
            for geom in sizes:
                header_keys.append(geom)
                width = sizes[geom]
                line.append(geom.ljust(width))

            # Add header
            table_lines.append(column_separator.join(line))

            # Add content
            for prop in prop_set:
                line = []
                for key in header_keys:
                    if key == &#39;key&#39;:
                        width = sizes[key]
                        line.append(prop.ljust(width))
                        continue

                    for entry in entries:
                        if entry[&#39;key&#39;] != key:
                            continue
                        value = entry[prop] if prop in entry else &#39;-&#39;
                        width = sizes[key]
                        line.append(value.ljust(width))

                table_lines.append(column_separator.join(line))

        return &#39;\n&#39;.join(table_lines)

    def print_as_table(self, props_in_header=True, column_separator=&#39;  &#39;):
        &#34;&#34;&#34;Method to print the table returned from the get_table method
        &#34;&#34;&#34;
        print(self.get_table(props_in_header, column_separator))
        return self

# -----------------------------------------------------------------------------
# Domain input builder - setting keys for various common problem definitions
# -----------------------------------------------------------------------------


def get_file_extension(file_name):
    return file_name.split(&#39;.&#39;)[-1]


class DomainBuilder:

    def __init__(self, run, name=&#39;domain&#39;):
        self.run = run
        self.run.Domain.GeomName = name


    def __file_check(self, file_name, key_path):
        &#34;&#34;&#34;Checking files and setting keys for FileName keys
        &#34;&#34;&#34;
        container = self.run.get_selection_from_location(key_path)[0]
        container.FileName = file_name
        if get_file_extension(file_name) == &#39;pfb&#39;:
            container.Type = &#39;PFBFile&#39;
            return self
        if get_file_extension(file_name) == &#39;nc&#39;:
            container.Type = &#39;NCFile&#39;
            return self
        else:
            raise Exception(f&#39;File extension {get_file_extension(file_name)} &#39;
                            f&#39;for {file_name} is invalid&#39;)
            return self

    def water(self, geom_name=None):
        &#34;&#34;&#34;Setting keys for water properties and gravity
        &#34;&#34;&#34;
        self.run.Gravity = 1.0
        self.run.Phase.Names = &#39;water&#39;
        self.run.Phase.water.Density.Type = &#39;Constant&#39;
        self.run.Phase.water.Density.Value = 1.0
        self.run.Phase.water.Viscosity.Type = &#39;Constant&#39;
        self.run.Phase.water.Viscosity.Value = 1.0
        self.run.Phase.water.Mobility.Type = &#39;Constant&#39;
        self.run.Phase.water.Mobility.Value = 1.0
        self.run.PhaseSources.water.Type = &#39;Constant&#39;

        if geom_name:
            self.run.PhaseSources.water.GeomNames = geom_name
            self.run.PhaseSources.water.Geom[geom_name].Value = 0.0

        return self

    def no_wells(self):
        &#34;&#34;&#34;Setting key with no wells
        &#34;&#34;&#34;
        self.run.Wells.Names = &#39;&#39;

        return self

    def no_contaminants(self):
        &#34;&#34;&#34;Setting key with no contaminants
        &#34;&#34;&#34;
        self.run.Contaminants.Names = &#39;&#39;

        return self

    def variably_saturated(self):
        &#34;&#34;&#34;Setting keys for variably saturated domain.
        Solver settings taken from default_richards test case
        &#34;&#34;&#34;
        self.run.Solver = &#39;Richards&#39;
        self.run.Solver.MaxIter = 5
        self.run.Solver.Nonlinear.MaxIter = 10
        self.run.Solver.Nonlinear.ResidualTol = 1e-9
        self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
        self.run.Solver.Nonlinear.EtaValue = 1e-5
        self.run.Solver.Nonlinear.UseJacobian = True
        self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
        self.run.Solver.Linear.KrylovDimension = 10
        self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

        return self

    def fully_saturated(self):
        &#34;&#34;&#34;Fully saturated solver settings (other than solver =&#39;Impes&#39;)
        taken from default_richards test case - need to change
        &#34;&#34;&#34;
        self.run.Solver = &#39;Impes&#39;
        self.run.Solver.MaxIter = 5
        self.run.Solver.Nonlinear.MaxIter = 10
        self.run.Solver.Nonlinear.ResidualTol = 1e-9
        self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
        self.run.Solver.Nonlinear.EtaValue = 1e-5
        self.run.Solver.Nonlinear.UseJacobian = True
        self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
        self.run.Solver.Linear.KrylovDimension = 10
        self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

        return self

    def homogeneous_subsurface(self, domain_name, perm=None, porosity=None,
                               specific_storage=None, rel_perm=None,
                               saturation=None, isotropic=False):
        &#34;&#34;&#34;Setting constant parameters for homogeneous subsurface
        &#34;&#34;&#34;
        if perm is not None:
            if not self.run.Geom.Perm.Names:
                self.run.Geom.Perm.Names = []

            self.run.Geom.Perm._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.Geom.Perm.Names += [domain_name]

            # checking for Perm file
            if isinstance(perm, str):
                self.__file_check(perm, f&#39;Geom/{domain_name}/Perm&#39;)
            else:
                self.run.Geom[domain_name].Perm.Type = &#39;Constant&#39;
                self.run.Geom[domain_name].Perm.Value = perm

        if porosity is not None:
            if not self.run.Geom.Porosity.GeomNames:
                self.run.Geom.Porosity.GeomNames = []

            self.run.Geom.Porosity._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Geom.Porosity.GeomNames += [domain_name]

            # checking for Porosity file
            if isinstance(porosity, str):
                self.__file_check(porosity, f&#39;Geom/{domain_name}/Porosity&#39;)
            else:
                self.run.Geom[domain_name].Porosity.Type = &#39;Constant&#39;
                self.run.Geom[domain_name].Porosity.Value = porosity

        if specific_storage is not None:
            if not self.run.SpecificStorage.GeomNames:
                self.run.SpecificStorage.GeomNames = []

            self.run.SpecificStorage._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.SpecificStorage.GeomNames += [domain_name]
            self.run.SpecificStorage.Type = &#39;Constant&#39;
            self.run.Geom[domain_name].SpecificStorage.Value = specific_storage

        if rel_perm is not None:
            if not self.run.Phase.RelPerm.GeomNames:
                self.run.Phase.RelPerm.GeomNames = []

            self.run.Phase.RelPerm.Type = rel_perm[&#39;Type&#39;]
            self.run.Phase.RelPerm._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Phase.RelPerm.GeomNames += [domain_name]
            if rel_perm[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
                self.run.Geom[domain_name].RelPerm.Alpha = rel_perm[&#39;Alpha&#39;]
                self.run.Geom[domain_name].RelPerm.N = rel_perm[&#39;N&#39;]

        if saturation is not None:
            if not self.run.Phase.Saturation.GeomNames:
                self.run.Phase.Saturation.GeomNames = []

            self.run.Phase.Saturation.Type = saturation[&#39;Type&#39;]
            self.run.Phase.Saturation._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Phase.Saturation.GeomNames += [domain_name]
            if saturation[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
                # defaulting to RelPerm not working
                self.run.Geom[domain_name].Saturation.Alpha = \
                    saturation[&#39;Alpha&#39;] if saturation[&#39;Alpha&#39;] \
                    else rel_perm[&#39;Alpha&#39;]
                self.run.Geom[domain_name].Saturation.N = \
                    saturation[&#39;N&#39;] if saturation[&#39;N&#39;] else rel_perm[&#39;N&#39;]
                self.run.Geom[domain_name].Saturation.SRes = saturation[&#39;SRes&#39;]
                self.run.Geom[domain_name].Saturation.SSat = saturation[&#39;SSat&#39;]

        if isotropic:
            self.run.Perm.TensorType = &#39;TensorByGeom&#39;

            if not self.run.Geom.Perm.TensorByGeom.Names:
                self.run.Geom.Perm.TensorByGeom.Names = []

            self.run.Geom.Perm.TensorByGeom._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.Geom.Perm.TensorByGeom.Names += [domain_name]
            self.run.Geom[domain_name].Perm.TensorValX = 1.0
            self.run.Geom[domain_name].Perm.TensorValY = 1.0
            self.run.Geom[domain_name].Perm.TensorValZ = 1.0

        return self

    def box_domain(self, box_input, domain_geom_name,
                   bounds=None, patches=None):
        &#34;&#34;&#34;Defining box domain and extents
        &#34;&#34;&#34;

        if not self.run.GeomInput.Names:
            self.run.GeomInput.Names = []

        if box_input not in self.run.GeomInput.Names:
            self.run.GeomInput._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.GeomInput.Names += [box_input]

        if not self.run.GeomInput[box_input].InputType:
            self.run.GeomInput[box_input].InputType = &#39;Box&#39;

        if not self.run.GeomInput[box_input].GeomName:
            self.run.GeomInput[box_input].GeomName = []

        if domain_geom_name not in self.run.GeomInput[box_input].GeomName:
            self.run.GeomInput[box_input]._details_[&#39;GeomName&#39;][&#39;history&#39;] = []
            self.run.GeomInput[box_input].GeomName += [domain_geom_name]

        if bounds is None:
            self.run.Geom[domain_geom_name].Lower.X = 0.0
            self.run.Geom[domain_geom_name].Lower.Y = 0.0
            self.run.Geom[domain_geom_name].Lower.Z = 0.0
            grid = self.run.ComputationalGrid
            self.run.Geom[domain_geom_name].Upper.X = grid.DX * grid.NX
            self.run.Geom[domain_geom_name].Upper.Y = grid.DY * grid.NY
            self.run.Geom[domain_geom_name].Upper.Z = grid.DZ * grid.NZ

        else:
            self.run.Geom[domain_geom_name].Lower.X = bounds[0]
            self.run.Geom[domain_geom_name].Upper.X = bounds[1]
            self.run.Geom[domain_geom_name].Lower.Y = bounds[2]
            self.run.Geom[domain_geom_name].Upper.Y = bounds[3]
            self.run.Geom[domain_geom_name].Lower.Z = bounds[4]
            self.run.Geom[domain_geom_name].Upper.Z = bounds[5]

        if patches:
            self.run.Geom[domain_geom_name].Patches = patches

        return self

    def slopes_mannings(self, domain_geom_name, slope_x=None,
                        slope_y=None, mannings=None):
        &#34;&#34;&#34;Setting slopes and mannings coefficients as constant value
        or from an external file
        &#34;&#34;&#34;
        if slope_x is not None:
            self.run.TopoSlopesX.GeomNames = domain_geom_name
            if isinstance(slope_x, str):
                self.__file_check(slope_x, &#39;TopoSlopesX&#39;)
            else:
                self.run.TopoSlopesX.Type = &#39;Constant&#39;
                self.run.TopoSlopesX.Geom[domain_geom_name].Value = slope_x
        if slope_y is not None:
            self.run.TopoSlopesY.GeomNames = domain_geom_name
            if isinstance(slope_y, str):
                self.__file_check(slope_y, &#39;TopoSlopesY&#39;)
            else:
                self.run.TopoSlopesY.Type = &#39;Constant&#39;
                self.run.TopoSlopesY.Geom[domain_geom_name].Value = slope_y
        if mannings is not None:
            self.run.Mannings.GeomNames = domain_geom_name
            if isinstance(mannings, str):
                self.__file_check(mannings, &#39;Mannings&#39;)
            else:
                self.run.Mannings.Type = &#39;Constant&#39;
                self.run.Mannings.Geom[domain_geom_name].Value = mannings

        return self

    def zero_flux(self, patches, cycle_name, interval_name):
        &#34;&#34;&#34;Setting zero-flux boundary condition for patch or patches
        &#34;&#34;&#34;
        if not self.run.BCPressure.PatchNames:
            self.run.BCPressure.PatchNames = []

        for patch in patches.split():
            self.run.BCPressure._details_[&#39;PatchNames&#39;][&#39;history&#39;] = []
            self.run.BCPressure.PatchNames += [patch]
            self.run.Patch[patch].BCPressure.Type = &#39;FluxConst&#39;
            self.run.Patch[patch].BCPressure.Cycle = cycle_name
            self.run.Patch[patch].BCPressure[interval_name].Value = 0.0

        return self

    def ic_pressure(self, domain_geom_name, patch, pressure):
        &#34;&#34;&#34;Setting initial condition pressure from file or to constant value
        &#34;&#34;&#34;
        self.run.ICPressure.GeomNames = domain_geom_name
        self.run.Geom[domain_geom_name].ICPressure.RefPatch = patch

        if isinstance(pressure, str) and get_file_extension(pressure) == &#39;pfb&#39;:
            self.run.ICPressure.Type = &#39;PFBFile&#39;
            self.run.Geom.domain.ICPressure.FileName = pressure
        elif isinstance(pressure, float) or isinstance(pressure, int):
            self.run.ICPressure.Type = &#39;HydroStaticPatch&#39;
            self.run.Geom.domain.ICPressure.Value = pressure
        else:
            raise Exception(f&#39;Incompatible type or file of {pressure}&#39;)

        return self

    def clm(self, met_file_name, top_patch, cycle_name, interval_name):
        &#34;&#34;&#34;Setting keys associated with CLM
        &#34;&#34;&#34;
        # ensure time step is hourly
        self.run.TimeStep.Type = &#39;Constant&#39;
        self.run.TimeStep.Value = 1.0
        # ensure OverlandFlow is the top boundary condition
        self.run.Patch[top_patch].BCPressure.Type = &#39;OverlandFlow&#39;
        self.run.Patch[top_patch].BCPressure.Cycle = cycle_name
        self.run.Patch[top_patch].BCPressure[interval_name].Value = 0.0
        # set CLM keys
        self.run.Solver.LSM = &#39;CLM&#39;
        self.run.Solver.CLM.CLMFileDir = &#34;.&#34;
        self.run.Solver.PrintCLM = True
        self.run.Solver.CLM.Print1dOut = False
        self.run.Solver.BinaryOutDir = False
        self.run.Solver.CLM.DailyRST = True
        self.run.Solver.CLM.SingleFile = True
        self.run.Solver.CLM.CLMDumpInterval = 24
        self.run.Solver.CLM.WriteLogs = False
        self.run.Solver.CLM.WriteLastRST = True
        self.run.Solver.CLM.MetForcing = &#39;1D&#39;
        self.run.Solver.CLM.MetFileName = met_file_name
        self.run.Solver.CLM.MetFilePath = &#34;.&#34;
        self.run.Solver.CLM.MetFileNT = 24
        self.run.Solver.CLM.IstepStart = 1.0
        self.run.Solver.CLM.EvapBeta = &#39;Linear&#39;
        self.run.Solver.CLM.VegWaterStress = &#39;Saturation&#39;
        self.run.Solver.CLM.ResSat = 0.1
        self.run.Solver.CLM.WiltingPoint = 0.12
        self.run.Solver.CLM.FieldCapacity = 0.98
        self.run.Solver.CLM.IrrigationType = &#39;none&#39;

        return self

    def well(self, name, type, x, y, z_upper, z_lower,
                     cycle_name, interval_name, action=&#39;Extraction&#39;,
                     saturation=1.0, phase=&#39;water&#39;, hydrostatic_pressure=None,
                     value=None):
        &#34;&#34;&#34;Setting keys necessary to define a simple well
        &#34;&#34;&#34;

        if not self.run.Wells.Names:
            self.run.Wells.Names = []

        self.run.Wells.Names += [name]
        well = self.run.Wells[name]
        well.InputType = &#39;Vertical&#39;
        well.Action = &#39;Extraction&#39;
        well.Type = type
        well.X = x
        well.Y = y
        well.ZUpper = z_upper
        well.ZLower = z_lower
        well.Method = &#39;Standard&#39;
        well.Cycle = cycle_name
        well[interval_name].Saturation[phase].Value = saturation

        if action == &#39;Extraction&#39;:
            well.Action = &#39;Extraction&#39;
            if type == &#39;Pressure&#39;:
                well[interval_name].Pressure.Value = hydrostatic_pressure
                if value is not None:
                    well[interval_name].Extraction.Pressure.Value = value
            elif type == &#39;Flux&#39; and value is not None:
                well[interval_name].Extraction.Flux[phase].Value = value

        if action == &#39;Injection&#39;:
            well.Action = &#39;Injection&#39;
            if type == &#39;Pressure&#39;:
                well[interval_name].Pressure.Value = hydrostatic_pressure
                if value is not None:
                    well[interval_name].Injection.Pressure.Value = value
            elif type == &#39;Flux&#39; and value is not None:
                well[interval_name].Injection.Flux[phase].Value = value

        return self

    def spinup_timing(self, initial_step, dump_interval):
        &#34;&#34;&#34;Setting keys to assist a spinup run
        &#34;&#34;&#34;

        self.run.TimingInfo.BaseUnit = 1
        self.run.TimingInfo.StartCount = 0
        self.run.TimingInfo.StartTime = 0.0
        self.run.TimingInfo.StopTime = 10000000
        self.run.TimingInfo.DumpInterval = dump_interval
        self.run.TimeStep.Type = &#39;Growth&#39;
        self.run.TimeStep.InitialStep = initial_step
        self.run.TimeStep.GrowthFactor = 1.1
        self.run.TimeStep.MaxStep = 1000000
        self.run.TimeStep.MinStep = 0.1

        return self</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parflow.tools.builders.get_file_extension"><code class="name flex">
<span>def <span class="ident">get_file_extension</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_extension(file_name):
    return file_name.split(&#39;.&#39;)[-1]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="parflow.tools.builders.DomainBuilder"><code class="flex name class">
<span>class <span class="ident">DomainBuilder</span></span>
<span>(</span><span>run, name='domain')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DomainBuilder:

    def __init__(self, run, name=&#39;domain&#39;):
        self.run = run
        self.run.Domain.GeomName = name


    def __file_check(self, file_name, key_path):
        &#34;&#34;&#34;Checking files and setting keys for FileName keys
        &#34;&#34;&#34;
        container = self.run.get_selection_from_location(key_path)[0]
        container.FileName = file_name
        if get_file_extension(file_name) == &#39;pfb&#39;:
            container.Type = &#39;PFBFile&#39;
            return self
        if get_file_extension(file_name) == &#39;nc&#39;:
            container.Type = &#39;NCFile&#39;
            return self
        else:
            raise Exception(f&#39;File extension {get_file_extension(file_name)} &#39;
                            f&#39;for {file_name} is invalid&#39;)
            return self

    def water(self, geom_name=None):
        &#34;&#34;&#34;Setting keys for water properties and gravity
        &#34;&#34;&#34;
        self.run.Gravity = 1.0
        self.run.Phase.Names = &#39;water&#39;
        self.run.Phase.water.Density.Type = &#39;Constant&#39;
        self.run.Phase.water.Density.Value = 1.0
        self.run.Phase.water.Viscosity.Type = &#39;Constant&#39;
        self.run.Phase.water.Viscosity.Value = 1.0
        self.run.Phase.water.Mobility.Type = &#39;Constant&#39;
        self.run.Phase.water.Mobility.Value = 1.0
        self.run.PhaseSources.water.Type = &#39;Constant&#39;

        if geom_name:
            self.run.PhaseSources.water.GeomNames = geom_name
            self.run.PhaseSources.water.Geom[geom_name].Value = 0.0

        return self

    def no_wells(self):
        &#34;&#34;&#34;Setting key with no wells
        &#34;&#34;&#34;
        self.run.Wells.Names = &#39;&#39;

        return self

    def no_contaminants(self):
        &#34;&#34;&#34;Setting key with no contaminants
        &#34;&#34;&#34;
        self.run.Contaminants.Names = &#39;&#39;

        return self

    def variably_saturated(self):
        &#34;&#34;&#34;Setting keys for variably saturated domain.
        Solver settings taken from default_richards test case
        &#34;&#34;&#34;
        self.run.Solver = &#39;Richards&#39;
        self.run.Solver.MaxIter = 5
        self.run.Solver.Nonlinear.MaxIter = 10
        self.run.Solver.Nonlinear.ResidualTol = 1e-9
        self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
        self.run.Solver.Nonlinear.EtaValue = 1e-5
        self.run.Solver.Nonlinear.UseJacobian = True
        self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
        self.run.Solver.Linear.KrylovDimension = 10
        self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

        return self

    def fully_saturated(self):
        &#34;&#34;&#34;Fully saturated solver settings (other than solver =&#39;Impes&#39;)
        taken from default_richards test case - need to change
        &#34;&#34;&#34;
        self.run.Solver = &#39;Impes&#39;
        self.run.Solver.MaxIter = 5
        self.run.Solver.Nonlinear.MaxIter = 10
        self.run.Solver.Nonlinear.ResidualTol = 1e-9
        self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
        self.run.Solver.Nonlinear.EtaValue = 1e-5
        self.run.Solver.Nonlinear.UseJacobian = True
        self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
        self.run.Solver.Linear.KrylovDimension = 10
        self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

        return self

    def homogeneous_subsurface(self, domain_name, perm=None, porosity=None,
                               specific_storage=None, rel_perm=None,
                               saturation=None, isotropic=False):
        &#34;&#34;&#34;Setting constant parameters for homogeneous subsurface
        &#34;&#34;&#34;
        if perm is not None:
            if not self.run.Geom.Perm.Names:
                self.run.Geom.Perm.Names = []

            self.run.Geom.Perm._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.Geom.Perm.Names += [domain_name]

            # checking for Perm file
            if isinstance(perm, str):
                self.__file_check(perm, f&#39;Geom/{domain_name}/Perm&#39;)
            else:
                self.run.Geom[domain_name].Perm.Type = &#39;Constant&#39;
                self.run.Geom[domain_name].Perm.Value = perm

        if porosity is not None:
            if not self.run.Geom.Porosity.GeomNames:
                self.run.Geom.Porosity.GeomNames = []

            self.run.Geom.Porosity._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Geom.Porosity.GeomNames += [domain_name]

            # checking for Porosity file
            if isinstance(porosity, str):
                self.__file_check(porosity, f&#39;Geom/{domain_name}/Porosity&#39;)
            else:
                self.run.Geom[domain_name].Porosity.Type = &#39;Constant&#39;
                self.run.Geom[domain_name].Porosity.Value = porosity

        if specific_storage is not None:
            if not self.run.SpecificStorage.GeomNames:
                self.run.SpecificStorage.GeomNames = []

            self.run.SpecificStorage._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.SpecificStorage.GeomNames += [domain_name]
            self.run.SpecificStorage.Type = &#39;Constant&#39;
            self.run.Geom[domain_name].SpecificStorage.Value = specific_storage

        if rel_perm is not None:
            if not self.run.Phase.RelPerm.GeomNames:
                self.run.Phase.RelPerm.GeomNames = []

            self.run.Phase.RelPerm.Type = rel_perm[&#39;Type&#39;]
            self.run.Phase.RelPerm._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Phase.RelPerm.GeomNames += [domain_name]
            if rel_perm[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
                self.run.Geom[domain_name].RelPerm.Alpha = rel_perm[&#39;Alpha&#39;]
                self.run.Geom[domain_name].RelPerm.N = rel_perm[&#39;N&#39;]

        if saturation is not None:
            if not self.run.Phase.Saturation.GeomNames:
                self.run.Phase.Saturation.GeomNames = []

            self.run.Phase.Saturation.Type = saturation[&#39;Type&#39;]
            self.run.Phase.Saturation._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
            self.run.Phase.Saturation.GeomNames += [domain_name]
            if saturation[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
                # defaulting to RelPerm not working
                self.run.Geom[domain_name].Saturation.Alpha = \
                    saturation[&#39;Alpha&#39;] if saturation[&#39;Alpha&#39;] \
                    else rel_perm[&#39;Alpha&#39;]
                self.run.Geom[domain_name].Saturation.N = \
                    saturation[&#39;N&#39;] if saturation[&#39;N&#39;] else rel_perm[&#39;N&#39;]
                self.run.Geom[domain_name].Saturation.SRes = saturation[&#39;SRes&#39;]
                self.run.Geom[domain_name].Saturation.SSat = saturation[&#39;SSat&#39;]

        if isotropic:
            self.run.Perm.TensorType = &#39;TensorByGeom&#39;

            if not self.run.Geom.Perm.TensorByGeom.Names:
                self.run.Geom.Perm.TensorByGeom.Names = []

            self.run.Geom.Perm.TensorByGeom._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.Geom.Perm.TensorByGeom.Names += [domain_name]
            self.run.Geom[domain_name].Perm.TensorValX = 1.0
            self.run.Geom[domain_name].Perm.TensorValY = 1.0
            self.run.Geom[domain_name].Perm.TensorValZ = 1.0

        return self

    def box_domain(self, box_input, domain_geom_name,
                   bounds=None, patches=None):
        &#34;&#34;&#34;Defining box domain and extents
        &#34;&#34;&#34;

        if not self.run.GeomInput.Names:
            self.run.GeomInput.Names = []

        if box_input not in self.run.GeomInput.Names:
            self.run.GeomInput._details_[&#39;Names&#39;][&#39;history&#39;] = []
            self.run.GeomInput.Names += [box_input]

        if not self.run.GeomInput[box_input].InputType:
            self.run.GeomInput[box_input].InputType = &#39;Box&#39;

        if not self.run.GeomInput[box_input].GeomName:
            self.run.GeomInput[box_input].GeomName = []

        if domain_geom_name not in self.run.GeomInput[box_input].GeomName:
            self.run.GeomInput[box_input]._details_[&#39;GeomName&#39;][&#39;history&#39;] = []
            self.run.GeomInput[box_input].GeomName += [domain_geom_name]

        if bounds is None:
            self.run.Geom[domain_geom_name].Lower.X = 0.0
            self.run.Geom[domain_geom_name].Lower.Y = 0.0
            self.run.Geom[domain_geom_name].Lower.Z = 0.0
            grid = self.run.ComputationalGrid
            self.run.Geom[domain_geom_name].Upper.X = grid.DX * grid.NX
            self.run.Geom[domain_geom_name].Upper.Y = grid.DY * grid.NY
            self.run.Geom[domain_geom_name].Upper.Z = grid.DZ * grid.NZ

        else:
            self.run.Geom[domain_geom_name].Lower.X = bounds[0]
            self.run.Geom[domain_geom_name].Upper.X = bounds[1]
            self.run.Geom[domain_geom_name].Lower.Y = bounds[2]
            self.run.Geom[domain_geom_name].Upper.Y = bounds[3]
            self.run.Geom[domain_geom_name].Lower.Z = bounds[4]
            self.run.Geom[domain_geom_name].Upper.Z = bounds[5]

        if patches:
            self.run.Geom[domain_geom_name].Patches = patches

        return self

    def slopes_mannings(self, domain_geom_name, slope_x=None,
                        slope_y=None, mannings=None):
        &#34;&#34;&#34;Setting slopes and mannings coefficients as constant value
        or from an external file
        &#34;&#34;&#34;
        if slope_x is not None:
            self.run.TopoSlopesX.GeomNames = domain_geom_name
            if isinstance(slope_x, str):
                self.__file_check(slope_x, &#39;TopoSlopesX&#39;)
            else:
                self.run.TopoSlopesX.Type = &#39;Constant&#39;
                self.run.TopoSlopesX.Geom[domain_geom_name].Value = slope_x
        if slope_y is not None:
            self.run.TopoSlopesY.GeomNames = domain_geom_name
            if isinstance(slope_y, str):
                self.__file_check(slope_y, &#39;TopoSlopesY&#39;)
            else:
                self.run.TopoSlopesY.Type = &#39;Constant&#39;
                self.run.TopoSlopesY.Geom[domain_geom_name].Value = slope_y
        if mannings is not None:
            self.run.Mannings.GeomNames = domain_geom_name
            if isinstance(mannings, str):
                self.__file_check(mannings, &#39;Mannings&#39;)
            else:
                self.run.Mannings.Type = &#39;Constant&#39;
                self.run.Mannings.Geom[domain_geom_name].Value = mannings

        return self

    def zero_flux(self, patches, cycle_name, interval_name):
        &#34;&#34;&#34;Setting zero-flux boundary condition for patch or patches
        &#34;&#34;&#34;
        if not self.run.BCPressure.PatchNames:
            self.run.BCPressure.PatchNames = []

        for patch in patches.split():
            self.run.BCPressure._details_[&#39;PatchNames&#39;][&#39;history&#39;] = []
            self.run.BCPressure.PatchNames += [patch]
            self.run.Patch[patch].BCPressure.Type = &#39;FluxConst&#39;
            self.run.Patch[patch].BCPressure.Cycle = cycle_name
            self.run.Patch[patch].BCPressure[interval_name].Value = 0.0

        return self

    def ic_pressure(self, domain_geom_name, patch, pressure):
        &#34;&#34;&#34;Setting initial condition pressure from file or to constant value
        &#34;&#34;&#34;
        self.run.ICPressure.GeomNames = domain_geom_name
        self.run.Geom[domain_geom_name].ICPressure.RefPatch = patch

        if isinstance(pressure, str) and get_file_extension(pressure) == &#39;pfb&#39;:
            self.run.ICPressure.Type = &#39;PFBFile&#39;
            self.run.Geom.domain.ICPressure.FileName = pressure
        elif isinstance(pressure, float) or isinstance(pressure, int):
            self.run.ICPressure.Type = &#39;HydroStaticPatch&#39;
            self.run.Geom.domain.ICPressure.Value = pressure
        else:
            raise Exception(f&#39;Incompatible type or file of {pressure}&#39;)

        return self

    def clm(self, met_file_name, top_patch, cycle_name, interval_name):
        &#34;&#34;&#34;Setting keys associated with CLM
        &#34;&#34;&#34;
        # ensure time step is hourly
        self.run.TimeStep.Type = &#39;Constant&#39;
        self.run.TimeStep.Value = 1.0
        # ensure OverlandFlow is the top boundary condition
        self.run.Patch[top_patch].BCPressure.Type = &#39;OverlandFlow&#39;
        self.run.Patch[top_patch].BCPressure.Cycle = cycle_name
        self.run.Patch[top_patch].BCPressure[interval_name].Value = 0.0
        # set CLM keys
        self.run.Solver.LSM = &#39;CLM&#39;
        self.run.Solver.CLM.CLMFileDir = &#34;.&#34;
        self.run.Solver.PrintCLM = True
        self.run.Solver.CLM.Print1dOut = False
        self.run.Solver.BinaryOutDir = False
        self.run.Solver.CLM.DailyRST = True
        self.run.Solver.CLM.SingleFile = True
        self.run.Solver.CLM.CLMDumpInterval = 24
        self.run.Solver.CLM.WriteLogs = False
        self.run.Solver.CLM.WriteLastRST = True
        self.run.Solver.CLM.MetForcing = &#39;1D&#39;
        self.run.Solver.CLM.MetFileName = met_file_name
        self.run.Solver.CLM.MetFilePath = &#34;.&#34;
        self.run.Solver.CLM.MetFileNT = 24
        self.run.Solver.CLM.IstepStart = 1.0
        self.run.Solver.CLM.EvapBeta = &#39;Linear&#39;
        self.run.Solver.CLM.VegWaterStress = &#39;Saturation&#39;
        self.run.Solver.CLM.ResSat = 0.1
        self.run.Solver.CLM.WiltingPoint = 0.12
        self.run.Solver.CLM.FieldCapacity = 0.98
        self.run.Solver.CLM.IrrigationType = &#39;none&#39;

        return self

    def well(self, name, type, x, y, z_upper, z_lower,
                     cycle_name, interval_name, action=&#39;Extraction&#39;,
                     saturation=1.0, phase=&#39;water&#39;, hydrostatic_pressure=None,
                     value=None):
        &#34;&#34;&#34;Setting keys necessary to define a simple well
        &#34;&#34;&#34;

        if not self.run.Wells.Names:
            self.run.Wells.Names = []

        self.run.Wells.Names += [name]
        well = self.run.Wells[name]
        well.InputType = &#39;Vertical&#39;
        well.Action = &#39;Extraction&#39;
        well.Type = type
        well.X = x
        well.Y = y
        well.ZUpper = z_upper
        well.ZLower = z_lower
        well.Method = &#39;Standard&#39;
        well.Cycle = cycle_name
        well[interval_name].Saturation[phase].Value = saturation

        if action == &#39;Extraction&#39;:
            well.Action = &#39;Extraction&#39;
            if type == &#39;Pressure&#39;:
                well[interval_name].Pressure.Value = hydrostatic_pressure
                if value is not None:
                    well[interval_name].Extraction.Pressure.Value = value
            elif type == &#39;Flux&#39; and value is not None:
                well[interval_name].Extraction.Flux[phase].Value = value

        if action == &#39;Injection&#39;:
            well.Action = &#39;Injection&#39;
            if type == &#39;Pressure&#39;:
                well[interval_name].Pressure.Value = hydrostatic_pressure
                if value is not None:
                    well[interval_name].Injection.Pressure.Value = value
            elif type == &#39;Flux&#39; and value is not None:
                well[interval_name].Injection.Flux[phase].Value = value

        return self

    def spinup_timing(self, initial_step, dump_interval):
        &#34;&#34;&#34;Setting keys to assist a spinup run
        &#34;&#34;&#34;

        self.run.TimingInfo.BaseUnit = 1
        self.run.TimingInfo.StartCount = 0
        self.run.TimingInfo.StartTime = 0.0
        self.run.TimingInfo.StopTime = 10000000
        self.run.TimingInfo.DumpInterval = dump_interval
        self.run.TimeStep.Type = &#39;Growth&#39;
        self.run.TimeStep.InitialStep = initial_step
        self.run.TimeStep.GrowthFactor = 1.1
        self.run.TimeStep.MaxStep = 1000000
        self.run.TimeStep.MinStep = 0.1

        return self</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parflow.tools.builders.DomainBuilder.box_domain"><code class="name flex">
<span>def <span class="ident">box_domain</span></span>(<span>self, box_input, domain_geom_name, bounds=None, patches=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defining box domain and extents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box_domain(self, box_input, domain_geom_name,
               bounds=None, patches=None):
    &#34;&#34;&#34;Defining box domain and extents
    &#34;&#34;&#34;

    if not self.run.GeomInput.Names:
        self.run.GeomInput.Names = []

    if box_input not in self.run.GeomInput.Names:
        self.run.GeomInput._details_[&#39;Names&#39;][&#39;history&#39;] = []
        self.run.GeomInput.Names += [box_input]

    if not self.run.GeomInput[box_input].InputType:
        self.run.GeomInput[box_input].InputType = &#39;Box&#39;

    if not self.run.GeomInput[box_input].GeomName:
        self.run.GeomInput[box_input].GeomName = []

    if domain_geom_name not in self.run.GeomInput[box_input].GeomName:
        self.run.GeomInput[box_input]._details_[&#39;GeomName&#39;][&#39;history&#39;] = []
        self.run.GeomInput[box_input].GeomName += [domain_geom_name]

    if bounds is None:
        self.run.Geom[domain_geom_name].Lower.X = 0.0
        self.run.Geom[domain_geom_name].Lower.Y = 0.0
        self.run.Geom[domain_geom_name].Lower.Z = 0.0
        grid = self.run.ComputationalGrid
        self.run.Geom[domain_geom_name].Upper.X = grid.DX * grid.NX
        self.run.Geom[domain_geom_name].Upper.Y = grid.DY * grid.NY
        self.run.Geom[domain_geom_name].Upper.Z = grid.DZ * grid.NZ

    else:
        self.run.Geom[domain_geom_name].Lower.X = bounds[0]
        self.run.Geom[domain_geom_name].Upper.X = bounds[1]
        self.run.Geom[domain_geom_name].Lower.Y = bounds[2]
        self.run.Geom[domain_geom_name].Upper.Y = bounds[3]
        self.run.Geom[domain_geom_name].Lower.Z = bounds[4]
        self.run.Geom[domain_geom_name].Upper.Z = bounds[5]

    if patches:
        self.run.Geom[domain_geom_name].Patches = patches

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.clm"><code class="name flex">
<span>def <span class="ident">clm</span></span>(<span>self, met_file_name, top_patch, cycle_name, interval_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting keys associated with CLM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clm(self, met_file_name, top_patch, cycle_name, interval_name):
    &#34;&#34;&#34;Setting keys associated with CLM
    &#34;&#34;&#34;
    # ensure time step is hourly
    self.run.TimeStep.Type = &#39;Constant&#39;
    self.run.TimeStep.Value = 1.0
    # ensure OverlandFlow is the top boundary condition
    self.run.Patch[top_patch].BCPressure.Type = &#39;OverlandFlow&#39;
    self.run.Patch[top_patch].BCPressure.Cycle = cycle_name
    self.run.Patch[top_patch].BCPressure[interval_name].Value = 0.0
    # set CLM keys
    self.run.Solver.LSM = &#39;CLM&#39;
    self.run.Solver.CLM.CLMFileDir = &#34;.&#34;
    self.run.Solver.PrintCLM = True
    self.run.Solver.CLM.Print1dOut = False
    self.run.Solver.BinaryOutDir = False
    self.run.Solver.CLM.DailyRST = True
    self.run.Solver.CLM.SingleFile = True
    self.run.Solver.CLM.CLMDumpInterval = 24
    self.run.Solver.CLM.WriteLogs = False
    self.run.Solver.CLM.WriteLastRST = True
    self.run.Solver.CLM.MetForcing = &#39;1D&#39;
    self.run.Solver.CLM.MetFileName = met_file_name
    self.run.Solver.CLM.MetFilePath = &#34;.&#34;
    self.run.Solver.CLM.MetFileNT = 24
    self.run.Solver.CLM.IstepStart = 1.0
    self.run.Solver.CLM.EvapBeta = &#39;Linear&#39;
    self.run.Solver.CLM.VegWaterStress = &#39;Saturation&#39;
    self.run.Solver.CLM.ResSat = 0.1
    self.run.Solver.CLM.WiltingPoint = 0.12
    self.run.Solver.CLM.FieldCapacity = 0.98
    self.run.Solver.CLM.IrrigationType = &#39;none&#39;

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.fully_saturated"><code class="name flex">
<span>def <span class="ident">fully_saturated</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fully saturated solver settings (other than solver ='Impes')
taken from default_richards test case - need to change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fully_saturated(self):
    &#34;&#34;&#34;Fully saturated solver settings (other than solver =&#39;Impes&#39;)
    taken from default_richards test case - need to change
    &#34;&#34;&#34;
    self.run.Solver = &#39;Impes&#39;
    self.run.Solver.MaxIter = 5
    self.run.Solver.Nonlinear.MaxIter = 10
    self.run.Solver.Nonlinear.ResidualTol = 1e-9
    self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
    self.run.Solver.Nonlinear.EtaValue = 1e-5
    self.run.Solver.Nonlinear.UseJacobian = True
    self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
    self.run.Solver.Linear.KrylovDimension = 10
    self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.homogeneous_subsurface"><code class="name flex">
<span>def <span class="ident">homogeneous_subsurface</span></span>(<span>self, domain_name, perm=None, porosity=None, specific_storage=None, rel_perm=None, saturation=None, isotropic=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting constant parameters for homogeneous subsurface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def homogeneous_subsurface(self, domain_name, perm=None, porosity=None,
                           specific_storage=None, rel_perm=None,
                           saturation=None, isotropic=False):
    &#34;&#34;&#34;Setting constant parameters for homogeneous subsurface
    &#34;&#34;&#34;
    if perm is not None:
        if not self.run.Geom.Perm.Names:
            self.run.Geom.Perm.Names = []

        self.run.Geom.Perm._details_[&#39;Names&#39;][&#39;history&#39;] = []
        self.run.Geom.Perm.Names += [domain_name]

        # checking for Perm file
        if isinstance(perm, str):
            self.__file_check(perm, f&#39;Geom/{domain_name}/Perm&#39;)
        else:
            self.run.Geom[domain_name].Perm.Type = &#39;Constant&#39;
            self.run.Geom[domain_name].Perm.Value = perm

    if porosity is not None:
        if not self.run.Geom.Porosity.GeomNames:
            self.run.Geom.Porosity.GeomNames = []

        self.run.Geom.Porosity._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
        self.run.Geom.Porosity.GeomNames += [domain_name]

        # checking for Porosity file
        if isinstance(porosity, str):
            self.__file_check(porosity, f&#39;Geom/{domain_name}/Porosity&#39;)
        else:
            self.run.Geom[domain_name].Porosity.Type = &#39;Constant&#39;
            self.run.Geom[domain_name].Porosity.Value = porosity

    if specific_storage is not None:
        if not self.run.SpecificStorage.GeomNames:
            self.run.SpecificStorage.GeomNames = []

        self.run.SpecificStorage._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
        self.run.SpecificStorage.GeomNames += [domain_name]
        self.run.SpecificStorage.Type = &#39;Constant&#39;
        self.run.Geom[domain_name].SpecificStorage.Value = specific_storage

    if rel_perm is not None:
        if not self.run.Phase.RelPerm.GeomNames:
            self.run.Phase.RelPerm.GeomNames = []

        self.run.Phase.RelPerm.Type = rel_perm[&#39;Type&#39;]
        self.run.Phase.RelPerm._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
        self.run.Phase.RelPerm.GeomNames += [domain_name]
        if rel_perm[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
            self.run.Geom[domain_name].RelPerm.Alpha = rel_perm[&#39;Alpha&#39;]
            self.run.Geom[domain_name].RelPerm.N = rel_perm[&#39;N&#39;]

    if saturation is not None:
        if not self.run.Phase.Saturation.GeomNames:
            self.run.Phase.Saturation.GeomNames = []

        self.run.Phase.Saturation.Type = saturation[&#39;Type&#39;]
        self.run.Phase.Saturation._details_[&#39;GeomNames&#39;][&#39;history&#39;] = []
        self.run.Phase.Saturation.GeomNames += [domain_name]
        if saturation[&#39;Type&#39;] == &#39;VanGenuchten&#39;:
            # defaulting to RelPerm not working
            self.run.Geom[domain_name].Saturation.Alpha = \
                saturation[&#39;Alpha&#39;] if saturation[&#39;Alpha&#39;] \
                else rel_perm[&#39;Alpha&#39;]
            self.run.Geom[domain_name].Saturation.N = \
                saturation[&#39;N&#39;] if saturation[&#39;N&#39;] else rel_perm[&#39;N&#39;]
            self.run.Geom[domain_name].Saturation.SRes = saturation[&#39;SRes&#39;]
            self.run.Geom[domain_name].Saturation.SSat = saturation[&#39;SSat&#39;]

    if isotropic:
        self.run.Perm.TensorType = &#39;TensorByGeom&#39;

        if not self.run.Geom.Perm.TensorByGeom.Names:
            self.run.Geom.Perm.TensorByGeom.Names = []

        self.run.Geom.Perm.TensorByGeom._details_[&#39;Names&#39;][&#39;history&#39;] = []
        self.run.Geom.Perm.TensorByGeom.Names += [domain_name]
        self.run.Geom[domain_name].Perm.TensorValX = 1.0
        self.run.Geom[domain_name].Perm.TensorValY = 1.0
        self.run.Geom[domain_name].Perm.TensorValZ = 1.0

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.ic_pressure"><code class="name flex">
<span>def <span class="ident">ic_pressure</span></span>(<span>self, domain_geom_name, patch, pressure)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting initial condition pressure from file or to constant value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ic_pressure(self, domain_geom_name, patch, pressure):
    &#34;&#34;&#34;Setting initial condition pressure from file or to constant value
    &#34;&#34;&#34;
    self.run.ICPressure.GeomNames = domain_geom_name
    self.run.Geom[domain_geom_name].ICPressure.RefPatch = patch

    if isinstance(pressure, str) and get_file_extension(pressure) == &#39;pfb&#39;:
        self.run.ICPressure.Type = &#39;PFBFile&#39;
        self.run.Geom.domain.ICPressure.FileName = pressure
    elif isinstance(pressure, float) or isinstance(pressure, int):
        self.run.ICPressure.Type = &#39;HydroStaticPatch&#39;
        self.run.Geom.domain.ICPressure.Value = pressure
    else:
        raise Exception(f&#39;Incompatible type or file of {pressure}&#39;)

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.no_contaminants"><code class="name flex">
<span>def <span class="ident">no_contaminants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting key with no contaminants</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_contaminants(self):
    &#34;&#34;&#34;Setting key with no contaminants
    &#34;&#34;&#34;
    self.run.Contaminants.Names = &#39;&#39;

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.no_wells"><code class="name flex">
<span>def <span class="ident">no_wells</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting key with no wells</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_wells(self):
    &#34;&#34;&#34;Setting key with no wells
    &#34;&#34;&#34;
    self.run.Wells.Names = &#39;&#39;

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.slopes_mannings"><code class="name flex">
<span>def <span class="ident">slopes_mannings</span></span>(<span>self, domain_geom_name, slope_x=None, slope_y=None, mannings=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting slopes and mannings coefficients as constant value
or from an external file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slopes_mannings(self, domain_geom_name, slope_x=None,
                    slope_y=None, mannings=None):
    &#34;&#34;&#34;Setting slopes and mannings coefficients as constant value
    or from an external file
    &#34;&#34;&#34;
    if slope_x is not None:
        self.run.TopoSlopesX.GeomNames = domain_geom_name
        if isinstance(slope_x, str):
            self.__file_check(slope_x, &#39;TopoSlopesX&#39;)
        else:
            self.run.TopoSlopesX.Type = &#39;Constant&#39;
            self.run.TopoSlopesX.Geom[domain_geom_name].Value = slope_x
    if slope_y is not None:
        self.run.TopoSlopesY.GeomNames = domain_geom_name
        if isinstance(slope_y, str):
            self.__file_check(slope_y, &#39;TopoSlopesY&#39;)
        else:
            self.run.TopoSlopesY.Type = &#39;Constant&#39;
            self.run.TopoSlopesY.Geom[domain_geom_name].Value = slope_y
    if mannings is not None:
        self.run.Mannings.GeomNames = domain_geom_name
        if isinstance(mannings, str):
            self.__file_check(mannings, &#39;Mannings&#39;)
        else:
            self.run.Mannings.Type = &#39;Constant&#39;
            self.run.Mannings.Geom[domain_geom_name].Value = mannings

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.spinup_timing"><code class="name flex">
<span>def <span class="ident">spinup_timing</span></span>(<span>self, initial_step, dump_interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting keys to assist a spinup run</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spinup_timing(self, initial_step, dump_interval):
    &#34;&#34;&#34;Setting keys to assist a spinup run
    &#34;&#34;&#34;

    self.run.TimingInfo.BaseUnit = 1
    self.run.TimingInfo.StartCount = 0
    self.run.TimingInfo.StartTime = 0.0
    self.run.TimingInfo.StopTime = 10000000
    self.run.TimingInfo.DumpInterval = dump_interval
    self.run.TimeStep.Type = &#39;Growth&#39;
    self.run.TimeStep.InitialStep = initial_step
    self.run.TimeStep.GrowthFactor = 1.1
    self.run.TimeStep.MaxStep = 1000000
    self.run.TimeStep.MinStep = 0.1

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.variably_saturated"><code class="name flex">
<span>def <span class="ident">variably_saturated</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting keys for variably saturated domain.
Solver settings taken from default_richards test case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variably_saturated(self):
    &#34;&#34;&#34;Setting keys for variably saturated domain.
    Solver settings taken from default_richards test case
    &#34;&#34;&#34;
    self.run.Solver = &#39;Richards&#39;
    self.run.Solver.MaxIter = 5
    self.run.Solver.Nonlinear.MaxIter = 10
    self.run.Solver.Nonlinear.ResidualTol = 1e-9
    self.run.Solver.Nonlinear.EtaChoice = &#39;EtaConstant&#39;
    self.run.Solver.Nonlinear.EtaValue = 1e-5
    self.run.Solver.Nonlinear.UseJacobian = True
    self.run.Solver.Nonlinear.DerivativeEpsilon = 1e-2
    self.run.Solver.Linear.KrylovDimension = 10
    self.run.Solver.Linear.Preconditioner = &#39;PFMG&#39;

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.water"><code class="name flex">
<span>def <span class="ident">water</span></span>(<span>self, geom_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting keys for water properties and gravity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def water(self, geom_name=None):
    &#34;&#34;&#34;Setting keys for water properties and gravity
    &#34;&#34;&#34;
    self.run.Gravity = 1.0
    self.run.Phase.Names = &#39;water&#39;
    self.run.Phase.water.Density.Type = &#39;Constant&#39;
    self.run.Phase.water.Density.Value = 1.0
    self.run.Phase.water.Viscosity.Type = &#39;Constant&#39;
    self.run.Phase.water.Viscosity.Value = 1.0
    self.run.Phase.water.Mobility.Type = &#39;Constant&#39;
    self.run.Phase.water.Mobility.Value = 1.0
    self.run.PhaseSources.water.Type = &#39;Constant&#39;

    if geom_name:
        self.run.PhaseSources.water.GeomNames = geom_name
        self.run.PhaseSources.water.Geom[geom_name].Value = 0.0

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.well"><code class="name flex">
<span>def <span class="ident">well</span></span>(<span>self, name, type, x, y, z_upper, z_lower, cycle_name, interval_name, action='Extraction', saturation=1.0, phase='water', hydrostatic_pressure=None, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting keys necessary to define a simple well</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def well(self, name, type, x, y, z_upper, z_lower,
                 cycle_name, interval_name, action=&#39;Extraction&#39;,
                 saturation=1.0, phase=&#39;water&#39;, hydrostatic_pressure=None,
                 value=None):
    &#34;&#34;&#34;Setting keys necessary to define a simple well
    &#34;&#34;&#34;

    if not self.run.Wells.Names:
        self.run.Wells.Names = []

    self.run.Wells.Names += [name]
    well = self.run.Wells[name]
    well.InputType = &#39;Vertical&#39;
    well.Action = &#39;Extraction&#39;
    well.Type = type
    well.X = x
    well.Y = y
    well.ZUpper = z_upper
    well.ZLower = z_lower
    well.Method = &#39;Standard&#39;
    well.Cycle = cycle_name
    well[interval_name].Saturation[phase].Value = saturation

    if action == &#39;Extraction&#39;:
        well.Action = &#39;Extraction&#39;
        if type == &#39;Pressure&#39;:
            well[interval_name].Pressure.Value = hydrostatic_pressure
            if value is not None:
                well[interval_name].Extraction.Pressure.Value = value
        elif type == &#39;Flux&#39; and value is not None:
            well[interval_name].Extraction.Flux[phase].Value = value

    if action == &#39;Injection&#39;:
        well.Action = &#39;Injection&#39;
        if type == &#39;Pressure&#39;:
            well[interval_name].Pressure.Value = hydrostatic_pressure
            if value is not None:
                well[interval_name].Injection.Pressure.Value = value
        elif type == &#39;Flux&#39; and value is not None:
            well[interval_name].Injection.Flux[phase].Value = value

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.DomainBuilder.zero_flux"><code class="name flex">
<span>def <span class="ident">zero_flux</span></span>(<span>self, patches, cycle_name, interval_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting zero-flux boundary condition for patch or patches</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zero_flux(self, patches, cycle_name, interval_name):
    &#34;&#34;&#34;Setting zero-flux boundary condition for patch or patches
    &#34;&#34;&#34;
    if not self.run.BCPressure.PatchNames:
        self.run.BCPressure.PatchNames = []

    for patch in patches.split():
        self.run.BCPressure._details_[&#39;PatchNames&#39;][&#39;history&#39;] = []
        self.run.BCPressure.PatchNames += [patch]
        self.run.Patch[patch].BCPressure.Type = &#39;FluxConst&#39;
        self.run.Patch[patch].BCPressure.Cycle = cycle_name
        self.run.Patch[patch].BCPressure[interval_name].Value = 0.0

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parflow.tools.builders.NoAliasDumper"><code class="flex name class">
<span>class <span class="ident">NoAliasDumper</span></span>
<span>(</span><span>stream, default_style=None, default_flow_style=False, canonical=None, indent=None, width=None, allow_unicode=None, line_break=None, encoding=None, explicit_start=None, explicit_end=None, version=None, tags=None, sort_keys=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoAliasDumper(yaml.SafeDumper):

    def ignore_aliases(self, data):
        &#34;&#34;&#34;addressing alias printing when applying database properties
        to multiple keys
        &#34;&#34;&#34;
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>yaml.dumper.SafeDumper</li>
<li>yaml.emitter.Emitter</li>
<li>yaml.serializer.Serializer</li>
<li>yaml.representer.SafeRepresenter</li>
<li>yaml.representer.BaseRepresenter</li>
<li>yaml.resolver.Resolver</li>
<li>yaml.resolver.BaseResolver</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="parflow.tools.builders.NoAliasDumper.ignore_aliases"><code class="name flex">
<span>def <span class="ident">ignore_aliases</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>addressing alias printing when applying database properties
to multiple keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore_aliases(self, data):
    &#34;&#34;&#34;addressing alias printing when applying database properties
    to multiple keys
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder"><code class="flex name class">
<span>class <span class="ident">SolidFileBuilder</span></span>
<span>(</span><span>top=1, bottom=2, side=3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolidFileBuilder:

    def __init__(self, top=1, bottom=2, side=3):
        self.name = None
        self.mask_array = None
        self.patch_ids_top = None
        self.patch_ids_bottom = None
        self.patch_ids_side = None
        self.top_id = top
        self.bottom_id = bottom
        self.side_id = side

    def mask(self, mask_array):
        &#34;&#34;&#34;Setting mask array to SolidFileBuilder object

        Args:
            mask_array (array): Array of values to define the mask.
        &#34;&#34;&#34;
        self.mask_array = mask_array
        return self

    def top(self, patch_id):
        &#34;&#34;&#34;Overwriting top patch ID

        Args:
            patch_id (int): ID of top patch in mask array
        &#34;&#34;&#34;
        self.top_id = patch_id
        self.patch_ids_top = None
        return self

    def bottom(self, patch_id):
        &#34;&#34;&#34;Overwriting bottom patch ID

        Args:
            patch_id (int): ID of bottom patch in mask array
        &#34;&#34;&#34;
        self.bottom_id = patch_id
        self.patch_ids_top = None
        return self

    def side(self, patch_id):
        &#34;&#34;&#34;Overwriting side patch ID

        Args:
            patch_id (int): ID of side patch in mask array
        &#34;&#34;&#34;
        self.side_id = patch_id
        self.patch_ids_side = None
        return self

    def top_ids(self, top_patch_ids):
        &#34;&#34;&#34;Overwriting top patch ID with multiple IDs

        Args:
            top_patch_ids (array): array of top patch ids
        &#34;&#34;&#34;
        self.patch_ids_top = top_patch_ids
        return self

    def bottom_ids(self, bottom_patch_ids):
        &#34;&#34;&#34;Overwriting bottom patch ID with multiple IDs

        Args:
            bottom_patch_ids (array): array of bottom patch ids
        &#34;&#34;&#34;
        self.patch_ids_bottom = bottom_patch_ids
        return self

    def side_ids(self, side_patch_ids):
        &#34;&#34;&#34;Overwriting side patch ID with multiple IDs

        Args:
            side_patch_ids (array): array of side patch ids
        &#34;&#34;&#34;
        self.patch_ids_side = side_patch_ids
        return self

    def write(self, name, xllcorner=0, yllcorner=0, cellsize=0, vtk=False):
        &#34;&#34;&#34;Writing out pfsol file with optional output to vtk

        Args:
            name (str): Name of solid file to write
            xllcorner (int, float): coordinate of lower-left corner of x-axis
            yllcorner (int, float): coordinate of lower-left corner of y-axis
            cellsize (int): size of horizontal grid cell for solid file
        &#34;&#34;&#34;
        self.name = name
        output_file_path = get_absolute_path(name)
        if self.mask_array is None:
            raise Exception(&#39;No mask was defined&#39;)

        jSize, iSize = self.mask_array.shape
        leftMask = np.zeros((jSize, iSize), dtype=np.int16)
        rightMask = np.zeros((jSize, iSize), dtype=np.int16)
        backMask = np.zeros((jSize, iSize), dtype=np.int16)
        frontMask = np.zeros((jSize, iSize), dtype=np.int16)
        bottomMask = np.zeros((jSize, iSize), dtype=np.int16)
        topMask = np.zeros((jSize, iSize), dtype=np.int16)

        for j in range(jSize):
            for i in range(iSize):
                if self.mask_array[j, i] != 0:
                    patch_value = 0 if self.patch_ids_side is None \
                        else self.patch_ids_side[j, i]
                    # Left (-x)
                    if i == 0 or self.mask_array[j, i-1] == 0:
                        leftMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Right (+x)
                    if i + 1 == iSize or self.mask_array[j, i+1] == 0:
                        rightMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Back (-y) (y flipped)
                    if j + 1 == jSize or self.mask_array[j+1, i] == 0:
                        backMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Front (+y) (y flipped)
                    if j == 0 or self.mask_array[j-1, i] == 0:
                        frontMask[j, i] = patch_value if patch_value \
                            else self.side_id

                    # Bottom (-z)
                    patch_value = 0 if self.patch_ids_bottom is None \
                        else self.patch_ids_bottom[j, i]
                    bottomMask[j, i] = patch_value if patch_value \
                        else self.bottom_id

                    # Top (+z)
                    patch_value = 0 if self.patch_ids_top is None \
                        else self.patch_ids_top[j, i]
                    topMask[j, i] = patch_value if patch_value \
                        else self.top_id

        # Generate asc / sa files
        writeFn = write_patch_matrix_as_asc
        settings = {
            &#39;xllcorner&#39;: xllcorner,
            &#39;yllcorner&#39;: yllcorner,
            &#39;cellsize&#39;: cellsize,
            &#39;NODATA_value&#39;: 0,
        }
        short_name = name[:-6]

        left_file_path = get_absolute_path(f&#39;{short_name}_left.asc&#39;)
        writeFn(leftMask, left_file_path, **settings)

        right_file_path = get_absolute_path(f&#39;{short_name}_right.asc&#39;)
        writeFn(rightMask, right_file_path, **settings)

        front_file_path = get_absolute_path(f&#39;{short_name}_front.asc&#39;)
        writeFn(frontMask, front_file_path, **settings)

        back_file_path = get_absolute_path(f&#39;{short_name}_back.asc&#39;)
        writeFn(backMask, back_file_path, **settings)

        top_file_path = get_absolute_path(f&#39;{short_name}_top.asc&#39;)
        writeFn(topMask, top_file_path, **settings)

        bottom_file_path = get_absolute_path(f&#39;{short_name}_bottom.asc&#39;)
        writeFn(bottomMask, bottom_file_path, **settings)

        # Trigger conversion
        print(&#39;=== pfmask-to-pfsol ===: BEGIN&#39;)
        extra = []
        if vtk:
            extra.append(&#39;--vtk&#39;)
            extra.append(f&#39;{output_file_path[:-6]}.vtk&#39;)
        os.system(f&#39;$PARFLOW_DIR/bin/pfmask-to-pfsol &#39;
                  f&#39;--mask-top {top_file_path} &#39;
                  f&#39;--mask-bottom {bottom_file_path} &#39;
                  f&#39;--mask-left {left_file_path} &#39;
                  f&#39;--mask-right {right_file_path} &#39;
                  f&#39;--mask-front {front_file_path} &#39;
                  f&#39;--mask-back {back_file_path} &#39;
                  f&#39;--pfsol {output_file_path} {&#34; &#34;.join(extra)}&#39;)
        print(&#39;=== pfmask-to-pfsol ===: END&#39;)
        return self

    def for_key(self, geomItem):
        &#34;&#34;&#34;Setting ParFlow keys associated with solid file

        Args:
            geomItem (str): Name of geometric unit in ParFlow run that will
            bet used as a token for the ParFlow key.
        &#34;&#34;&#34;
        geomItem.InputType = &#39;SolidFile&#39;
        geomItem.FileName = self.name
        return self</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parflow.tools.builders.SolidFileBuilder.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self, patch_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting bottom patch ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patch_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of bottom patch in mask array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom(self, patch_id):
    &#34;&#34;&#34;Overwriting bottom patch ID

    Args:
        patch_id (int): ID of bottom patch in mask array
    &#34;&#34;&#34;
    self.bottom_id = patch_id
    self.patch_ids_top = None
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.bottom_ids"><code class="name flex">
<span>def <span class="ident">bottom_ids</span></span>(<span>self, bottom_patch_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting bottom patch ID with multiple IDs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bottom_patch_ids</code></strong> :&ensp;<code>array</code></dt>
<dd>array of bottom patch ids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom_ids(self, bottom_patch_ids):
    &#34;&#34;&#34;Overwriting bottom patch ID with multiple IDs

    Args:
        bottom_patch_ids (array): array of bottom patch ids
    &#34;&#34;&#34;
    self.patch_ids_bottom = bottom_patch_ids
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.for_key"><code class="name flex">
<span>def <span class="ident">for_key</span></span>(<span>self, geomItem)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting ParFlow keys associated with solid file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geomItem</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of geometric unit in ParFlow run that will</dd>
</dl>
<p>bet used as a token for the ParFlow key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def for_key(self, geomItem):
    &#34;&#34;&#34;Setting ParFlow keys associated with solid file

    Args:
        geomItem (str): Name of geometric unit in ParFlow run that will
        bet used as a token for the ParFlow key.
    &#34;&#34;&#34;
    geomItem.InputType = &#39;SolidFile&#39;
    geomItem.FileName = self.name
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, mask_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Setting mask array to SolidFileBuilder object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mask_array</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of values to define the mask.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, mask_array):
    &#34;&#34;&#34;Setting mask array to SolidFileBuilder object

    Args:
        mask_array (array): Array of values to define the mask.
    &#34;&#34;&#34;
    self.mask_array = mask_array
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.side"><code class="name flex">
<span>def <span class="ident">side</span></span>(<span>self, patch_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting side patch ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patch_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of side patch in mask array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def side(self, patch_id):
    &#34;&#34;&#34;Overwriting side patch ID

    Args:
        patch_id (int): ID of side patch in mask array
    &#34;&#34;&#34;
    self.side_id = patch_id
    self.patch_ids_side = None
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.side_ids"><code class="name flex">
<span>def <span class="ident">side_ids</span></span>(<span>self, side_patch_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting side patch ID with multiple IDs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>side_patch_ids</code></strong> :&ensp;<code>array</code></dt>
<dd>array of side patch ids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def side_ids(self, side_patch_ids):
    &#34;&#34;&#34;Overwriting side patch ID with multiple IDs

    Args:
        side_patch_ids (array): array of side patch ids
    &#34;&#34;&#34;
    self.patch_ids_side = side_patch_ids
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self, patch_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting top patch ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patch_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID of top patch in mask array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self, patch_id):
    &#34;&#34;&#34;Overwriting top patch ID

    Args:
        patch_id (int): ID of top patch in mask array
    &#34;&#34;&#34;
    self.top_id = patch_id
    self.patch_ids_top = None
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.top_ids"><code class="name flex">
<span>def <span class="ident">top_ids</span></span>(<span>self, top_patch_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwriting top patch ID with multiple IDs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>top_patch_ids</code></strong> :&ensp;<code>array</code></dt>
<dd>array of top patch ids</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top_ids(self, top_patch_ids):
    &#34;&#34;&#34;Overwriting top patch ID with multiple IDs

    Args:
        top_patch_ids (array): array of top patch ids
    &#34;&#34;&#34;
    self.patch_ids_top = top_patch_ids
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SolidFileBuilder.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, name, xllcorner=0, yllcorner=0, cellsize=0, vtk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Writing out pfsol file with optional output to vtk</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of solid file to write</dd>
<dt><strong><code>xllcorner</code></strong> :&ensp;<code>int, float</code></dt>
<dd>coordinate of lower-left corner of x-axis</dd>
<dt><strong><code>yllcorner</code></strong> :&ensp;<code>int, float</code></dt>
<dd>coordinate of lower-left corner of y-axis</dd>
<dt><strong><code>cellsize</code></strong> :&ensp;<code>int</code></dt>
<dd>size of horizontal grid cell for solid file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, name, xllcorner=0, yllcorner=0, cellsize=0, vtk=False):
    &#34;&#34;&#34;Writing out pfsol file with optional output to vtk

    Args:
        name (str): Name of solid file to write
        xllcorner (int, float): coordinate of lower-left corner of x-axis
        yllcorner (int, float): coordinate of lower-left corner of y-axis
        cellsize (int): size of horizontal grid cell for solid file
    &#34;&#34;&#34;
    self.name = name
    output_file_path = get_absolute_path(name)
    if self.mask_array is None:
        raise Exception(&#39;No mask was defined&#39;)

    jSize, iSize = self.mask_array.shape
    leftMask = np.zeros((jSize, iSize), dtype=np.int16)
    rightMask = np.zeros((jSize, iSize), dtype=np.int16)
    backMask = np.zeros((jSize, iSize), dtype=np.int16)
    frontMask = np.zeros((jSize, iSize), dtype=np.int16)
    bottomMask = np.zeros((jSize, iSize), dtype=np.int16)
    topMask = np.zeros((jSize, iSize), dtype=np.int16)

    for j in range(jSize):
        for i in range(iSize):
            if self.mask_array[j, i] != 0:
                patch_value = 0 if self.patch_ids_side is None \
                    else self.patch_ids_side[j, i]
                # Left (-x)
                if i == 0 or self.mask_array[j, i-1] == 0:
                    leftMask[j, i] = patch_value if patch_value \
                        else self.side_id

                # Right (+x)
                if i + 1 == iSize or self.mask_array[j, i+1] == 0:
                    rightMask[j, i] = patch_value if patch_value \
                        else self.side_id

                # Back (-y) (y flipped)
                if j + 1 == jSize or self.mask_array[j+1, i] == 0:
                    backMask[j, i] = patch_value if patch_value \
                        else self.side_id

                # Front (+y) (y flipped)
                if j == 0 or self.mask_array[j-1, i] == 0:
                    frontMask[j, i] = patch_value if patch_value \
                        else self.side_id

                # Bottom (-z)
                patch_value = 0 if self.patch_ids_bottom is None \
                    else self.patch_ids_bottom[j, i]
                bottomMask[j, i] = patch_value if patch_value \
                    else self.bottom_id

                # Top (+z)
                patch_value = 0 if self.patch_ids_top is None \
                    else self.patch_ids_top[j, i]
                topMask[j, i] = patch_value if patch_value \
                    else self.top_id

    # Generate asc / sa files
    writeFn = write_patch_matrix_as_asc
    settings = {
        &#39;xllcorner&#39;: xllcorner,
        &#39;yllcorner&#39;: yllcorner,
        &#39;cellsize&#39;: cellsize,
        &#39;NODATA_value&#39;: 0,
    }
    short_name = name[:-6]

    left_file_path = get_absolute_path(f&#39;{short_name}_left.asc&#39;)
    writeFn(leftMask, left_file_path, **settings)

    right_file_path = get_absolute_path(f&#39;{short_name}_right.asc&#39;)
    writeFn(rightMask, right_file_path, **settings)

    front_file_path = get_absolute_path(f&#39;{short_name}_front.asc&#39;)
    writeFn(frontMask, front_file_path, **settings)

    back_file_path = get_absolute_path(f&#39;{short_name}_back.asc&#39;)
    writeFn(backMask, back_file_path, **settings)

    top_file_path = get_absolute_path(f&#39;{short_name}_top.asc&#39;)
    writeFn(topMask, top_file_path, **settings)

    bottom_file_path = get_absolute_path(f&#39;{short_name}_bottom.asc&#39;)
    writeFn(bottomMask, bottom_file_path, **settings)

    # Trigger conversion
    print(&#39;=== pfmask-to-pfsol ===: BEGIN&#39;)
    extra = []
    if vtk:
        extra.append(&#39;--vtk&#39;)
        extra.append(f&#39;{output_file_path[:-6]}.vtk&#39;)
    os.system(f&#39;$PARFLOW_DIR/bin/pfmask-to-pfsol &#39;
              f&#39;--mask-top {top_file_path} &#39;
              f&#39;--mask-bottom {bottom_file_path} &#39;
              f&#39;--mask-left {left_file_path} &#39;
              f&#39;--mask-right {right_file_path} &#39;
              f&#39;--mask-front {front_file_path} &#39;
              f&#39;--mask-back {back_file_path} &#39;
              f&#39;--pfsol {output_file_path} {&#34; &#34;.join(extra)}&#39;)
    print(&#39;=== pfmask-to-pfsol ===: END&#39;)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder"><code class="flex name class">
<span>class <span class="ident">SubsurfacePropertiesBuilder</span></span>
<span>(</span><span>run=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubsurfacePropertiesBuilder:

    def __init__(self, run=None):
        if run is not None:
            self.run = run
        self.output = {}
        self.name_registration = {}
        self.column_index = {}
        self.props_in_row_header = True
        self.table_comments = []
        yaml_key_def = os.path.join(
            os.path.dirname(__file__), &#39;ref/table_keys.yaml&#39;)
        with open(yaml_key_def, &#39;r&#39;) as file:
            self.definition = yaml.safe_load(file)

        # Extract prop column names
        self.prop_names = []
        self.alias_to_pfkey = {}
        self.pfkey_to_alias = {}
        self.alias_duplicates = set()
        for key, value in self.definition.items():
            self.pfkey_to_alias[key] = value[&#39;alias&#39;][0]
            for alias in value[&#39;alias&#39;]:
                # checking for duplicate aliases
                if alias in self.prop_names:
                    self.alias_duplicates.add(alias)

                self.prop_names.append(alias)
                self.alias_to_pfkey[alias] = key

        # crashes if there are duplicate aliases
        if self.alias_duplicates:
            raise Exception(f&#39;Warning - duplicate alias name(s):&#39;
                            f&#39; {self.alias_duplicates}&#39;)

    def _process_data_line(self, tokens):
        &#34;&#34;&#34;Method to process lines of data in a table
        &#34;&#34;&#34;
        # Skip new lines or comments
        if len(tokens) == 0 or tokens[0] == &#39;#&#39;:
            return

        if self.props_in_row_header:
            # Key column contains geom_name
            data = {}
            registrations = []
            for alias, col_idx in self.column_index.items():
                str_value = tokens[col_idx]
                if str_value == &#39;-&#39;:
                    continue

                key = self.alias_to_pfkey[alias]
                key_def = self.definition[key]
                value_type = key_def.get(&#39;type&#39;, &#39;float&#39;)
                value = __builtins__[value_type](str_value)
                data[key] = value

                # setting related addon keys
                if &#39;addon&#39; in key_def.keys():
                    for key, value in key_def[&#39;addon&#39;].items():
                        # local keys (appending to geom item)
                        if key[0] == &#39;.&#39;:
                            data.update({key[1:]: value})
                        # global keys
                        elif key not in self.output:
                            self.output.update({key: value})

                # appending geom name to list for setting geom name keys
                if &#39;register&#39; in key_def.keys():
                    registrations.append(key_def[&#39;register&#39;])

            # Extract geom_name
            geom_name = data[&#39;key&#39;]
            del data[&#39;key&#39;]
            self.output[geom_name] = data

            if not hasattr(self.name_registration, geom_name):
                self.name_registration[geom_name] = set()

            self.name_registration[geom_name].update(registrations)

        else:
            # Key column contains property values
            data = {}
            registrations = []

            main_key = &#39;key&#39;
            for key_alias in self.column_index:
                if key_alias in self.definition[&#39;key&#39;][&#39;alias&#39;]:
                    main_key = key_alias

            prop_alias = tokens[self.column_index[main_key]]
            key = self.alias_to_pfkey[prop_alias]
            key_def = self.definition[key]
            value_type = key_def.get(&#39;type&#39;, &#39;float&#39;)
            value_convert = __builtins__[value_type]
            # setting related addon keys
            if &#39;addon&#39; in key_def.keys():
                for addon_key, addon_value in key_def[&#39;addon&#39;].items():
                    # local keys (appending to geom item)
                    if addon_key[0] == &#39;.&#39;:
                        data.update({addon_key[1:]: addon_value})
                    # global keys
                    elif addon_key not in self.output:
                        self.output.update({addon_key: addon_value})

            # appending geom name to list for setting geom name keys
            if &#39;register&#39; in key_def.keys():
                registrations.append(key_def[&#39;register&#39;])

            for geom_name in self.column_index:
                if geom_name == main_key:
                    continue

                container = self.output[geom_name]
                value_str = tokens[self.column_index[geom_name]]
                if value_str == &#39;-&#39;:
                    continue

                value = value_convert(value_str)
                container[key] = value
                container.update(data)
                if registrations:
                    self.name_registration[geom_name].update(registrations)

    def _process_first_line(self, first_line_tokens):
        &#34;&#34;&#34;Method to process first line in a table
        &#34;&#34;&#34;
        # Skip new lines or comments
        if len(first_line_tokens) == 0:
            return False
        if first_line_tokens[0] == &#39;#&#39;:
            self.table_comments.append(&#34; &#34;.join(first_line_tokens))
            return False

        self.props_in_row_header = None
        found = []
        not_found = []
        index = 0
        for token in first_line_tokens:
            self.column_index[token] = index
            index += 1

            if token in self.alias_to_pfkey:
                found.append(token)
            else:
                not_found.append(token)

        if len(not_found) == 0:
            self.props_in_row_header = True
        elif len(found) &gt; 1 and len(not_found) &gt; 1:
            print(&#39;Error while processing input table:&#39;)
            print(f&#39; - Properties found: {found}&#39;)
            print(f&#39; - Properties not found: {not_found}&#39;)
        elif len(found) == 1:
            self.props_in_row_header = False
            # Prefill geo_name containers
            for geom_name in self.column_index:
                if geom_name not in self.definition[&#39;key&#39;][&#39;alias&#39;]:
                    self.output[geom_name] = {}
                    self.name_registration[geom_name] = set()

        if self.props_in_row_header is None:
            raise Exception(&#39;Invalid table format&#39;)

        return True

    def load_csv_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
        &#34;&#34;&#34;Method to load a .csv file of a table of subsurface parameters

        Args:
            tableFile (str): Path to the input .csv file.
            encoding=&#39;utf-8-sig&#39;: encoding of input file.
        &#34;&#34;&#34;
        with open(get_absolute_path(tableFile), &#39;r&#39;,
                  encoding=encoding) as csv_file:
            data_line = False
            for line in csv_file:
                tokens = _csv_line_tokenizer(line)
                if data_line:
                    self._process_data_line(tokens)
                else:
                    data_line = self._process_first_line(tokens)
        return self

    def load_txt_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
        &#34;&#34;&#34;Method to load a .txt file of a table of subsurface parameters

        Args:
            tableFile (str): Path to the input .txt file.
            encoding=&#39;utf-8-sig&#39;: encoding of input file.
        &#34;&#34;&#34;
        with open(get_absolute_path(tableFile), &#39;r&#39;,
                  encoding=encoding) as txt_file:
            data_line = False
            for line in txt_file:
                tokens = _txt_line_tokenizer(line)
                if data_line:
                    self._process_data_line(tokens)
                else:
                    data_line = self._process_first_line(tokens)

        return self

    def load_txt_content(self, txt_content):
        &#34;&#34;&#34;Method to load an in-line text table of subsurface parameters

        Args:
            txt_content (str): In-line text string.
        &#34;&#34;&#34;
        data_line = False
        for line in txt_content.splitlines():
            tokens = _txt_line_tokenizer(line)
            if data_line:
                self._process_data_line(tokens)
            else:
                data_line = self._process_first_line(tokens)

        return self

    def assign(self, old=None, new=None, mapping=None):
        &#34;&#34;&#34;Method to assigning subsurface properties of one unit to another

        Args:
            old=None (str): Source unit with existing parameters
            new=None (str): Target unit to which the parameters
                            from old will be mapped
            mapping=None (dict): Dictionary that includes the old units as keys
                and new units as values.
        &#34;&#34;&#34;
        # assigning subsurface properties of one unit to another
        if isinstance(new, list):
            for item in new:
                self.assign(old, item)

        elif old != new:
            data = self.output[old]
            self.output[new] = data

        if mapping is not None:
            for old, new in mapping.items():
                self.assign(old, new)

        return self

    def load_default_properties(self, database=&#39;conus_1&#39;):
        &#34;&#34;&#34;Method to load one of several default property databases.

        Args:
           database=&#39;conus_1&#39;: default database - options are:
           &#39;conus_1&#39;: soil/rock properties from Maxwell and Condon (2016)
           &#39;washita&#39;: soil/rock properties from Little Washita script
           &#39;freeze_cherry&#39;: soil/rock properties from Freeze and Cherry (1979)
           Note: Freeze and Cherry only has permeability and porosity
        &#34;&#34;&#34;
        database_file = &#39;ref/subsurface_&#39; + database + &#39;.txt&#39;

        default_prop_file = os.path.join(
            os.path.dirname(__file__), database_file)

        if exists(default_prop_file):
            self.load_txt_file(default_prop_file)
            print(&#39;#&#39;*80)
            print(&#39;# Loaded database:&#39;)
            for item in self.table_comments:
                print(item)
            print(&#39;#&#39; * 80)
        else:
            print(&#39;#&#39; * 80)
            print(f&#39;# {database} database not found. Available databases include:&#39;)
            for root, dirs, files in os.walk(os.path.dirname(__file__) + &#39;/ref/&#39;):
                for name in files:
                    if name.startswith(&#39;subsurface&#39;):
                        print(f&#39;# - {name} (use argument &#39;
                              f&#39;&#34;{name[len(&#34;subsurface_&#34;):-len(&#34;.txt&#34;)]}&#34;)&#39;)
            print(&#39;#&#39; * 80)


        return self

    def apply(self, run=None, name_registration=True):
        &#34;&#34;&#34;Method to apply the loaded subsurface properties to a given
           run object.

        Args:
            run=None (Run object): Run object to which the loaded subsurface
                parameters will be applied. If run=None, then the run object
                must be passed in as an argument when the
                SubsurfacePropertiesBuilder is instantiated.
            name_registration=True (bool): sets the auxiliary keys
                (e.g., GeomNames) related to the loaded subsurface properties
        &#34;&#34;&#34;
        # applying subsurface properties to run keys
        if run is None:
            if self.run is None:
                print(&#39;No run object assigned&#39;)
                sys.exit(1)
        else:
            self.run = run

        valid_geom_names = []
        addon_keys = {}
        for name in self.output:
            if name in self.run.Geom.__dict__.keys():
                valid_geom_names.append(name)
            elif name_registration and type(self.output[name]) is not dict:
                addon_keys[name] = self.output[name]

        # Run pfset on all geom sections
        for geom_name in valid_geom_names:
            self.run.Geom[geom_name].pfset(flat_map=self.output[geom_name])

        # Handle names
        if name_registration:
            names_to_set = addon_keys
            for geom_name in valid_geom_names:
                if geom_name in self.name_registration.keys():
                    for prop_name in self.name_registration[geom_name]:
                        if prop_name not in names_to_set.keys():
                            names_to_set[prop_name] = []
                        names_to_set[prop_name].append(geom_name)
            self.run.pfset(flat_map=names_to_set)

        return self

    def print(self):
        &#34;&#34;&#34;Method to print subsurface properties in hierarchical format
        &#34;&#34;&#34;
        output_to_print = {&#39;Geom&#39;: {}}
        valid_geom_names = []
        for geom_name in self.output:
            if hasattr(self.run.Geom, geom_name):
                valid_geom_names.append(geom_name)

        for geom_name in valid_geom_names:
            if hasattr(self.name_registration, geom_name):
                for prop_name in self.name_registration[geom_name]:
                    if not hasattr(output_to_print, prop_name):
                        output_to_print[prop_name] = []
                    output_to_print[prop_name].append(geom_name)

        for geom_name in valid_geom_names:
            output_to_print[&#39;Geom&#39;][geom_name] = self.output[geom_name]

        print(yaml.dump(sort_dict(output_to_print), Dumper=NoAliasDumper))
        return self

    def get_table(self, props_in_header=True, column_separator=&#39;  &#39;):
        &#34;&#34;&#34;Method to convert loaded subsurface properties into a table

        Args:
            props_in_header=True (bool): Defaults to returning a table with
                property values at the top of each column
            column_separator=&#39;  &#39; (str): Defaults to returning a table that
                is space-delimited.

        Returns:
            text block of table of subsurface units and parameter values
        &#34;&#34;&#34;
        entries = []
        prop_set = set()
        prop_sizes = {&#39;key&#39;: 0}
        geom_sizes = {&#39;key&#39;: 0}

        # Fill entries headers
        for geo_name, props in self.output.items():
            if not isinstance(props, dict):
                continue
            elif not hasattr(self.run.Geom, geo_name):
                continue

            entry = {
                &#39;key&#39;: geo_name,
            }
            prop_sizes[&#39;key&#39;] = max(prop_sizes[&#39;key&#39;], len(geo_name))
            geom_sizes[geo_name] = len(geo_name)
            for prop in props:
                if prop in self.pfkey_to_alias:
                    alias = self.pfkey_to_alias[prop]
                    value = str(props[prop])
                    size = len(value)
                    entry[alias] = value
                    prop_set.add(alias)

                    # Find bigger size for geom
                    geom_sizes[geo_name] = max(geom_sizes[geo_name], size)

                    # Find bigger size for props
                    if alias not in prop_sizes:
                        prop_sizes[alias] = max(size, len(alias))
                    else:
                        prop_sizes[alias] = max(prop_sizes[alias], size)

                    geom_sizes[&#39;key&#39;] = max(geom_sizes[&#39;key&#39;], len(alias))

            entries.append(entry)

        # Figure out orientation
        prop_header_width = 0
        for alias in prop_sizes:
            prop_header_width += prop_sizes[alias] + 2

        geom_header_width = 0
        for geom_name in geom_sizes:
            geom_header_width += geom_sizes[geom_name] + 2

        # Build table
        table_lines = []
        header_keys = []
        if props_in_header:
            sizes = prop_sizes
            # Create table using props as header
            line = []
            for prop in sizes:
                header_keys.append(prop)
                width = sizes[prop]
                line.append(prop.ljust(width))

            # Add header
            table_lines.append(column_separator.join(line))

            # Add content
            for entry in entries:
                line = []
                for key in header_keys:
                    value = entry[key] if key in entry else &#39;-&#39;
                    width = sizes[key]
                    line.append(value.ljust(width))
                table_lines.append(column_separator.join(line))

        else:
            sizes = geom_sizes
            # Create table using geom name as header
            line = []
            for geom in sizes:
                header_keys.append(geom)
                width = sizes[geom]
                line.append(geom.ljust(width))

            # Add header
            table_lines.append(column_separator.join(line))

            # Add content
            for prop in prop_set:
                line = []
                for key in header_keys:
                    if key == &#39;key&#39;:
                        width = sizes[key]
                        line.append(prop.ljust(width))
                        continue

                    for entry in entries:
                        if entry[&#39;key&#39;] != key:
                            continue
                        value = entry[prop] if prop in entry else &#39;-&#39;
                        width = sizes[key]
                        line.append(value.ljust(width))

                table_lines.append(column_separator.join(line))

        return &#39;\n&#39;.join(table_lines)

    def print_as_table(self, props_in_header=True, column_separator=&#39;  &#39;):
        &#34;&#34;&#34;Method to print the table returned from the get_table method
        &#34;&#34;&#34;
        print(self.get_table(props_in_header, column_separator))
        return self</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, run=None, name_registration=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to apply the loaded subsurface properties to a given
run object.</p>
<h2 id="args">Args</h2>
<p>run=None (Run object): Run object to which the loaded subsurface
parameters will be applied. If run=None, then the run object
must be passed in as an argument when the
SubsurfacePropertiesBuilder is instantiated.
name_registration=True (bool): sets the auxiliary keys
(e.g., GeomNames) related to the loaded subsurface properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, run=None, name_registration=True):
    &#34;&#34;&#34;Method to apply the loaded subsurface properties to a given
       run object.

    Args:
        run=None (Run object): Run object to which the loaded subsurface
            parameters will be applied. If run=None, then the run object
            must be passed in as an argument when the
            SubsurfacePropertiesBuilder is instantiated.
        name_registration=True (bool): sets the auxiliary keys
            (e.g., GeomNames) related to the loaded subsurface properties
    &#34;&#34;&#34;
    # applying subsurface properties to run keys
    if run is None:
        if self.run is None:
            print(&#39;No run object assigned&#39;)
            sys.exit(1)
    else:
        self.run = run

    valid_geom_names = []
    addon_keys = {}
    for name in self.output:
        if name in self.run.Geom.__dict__.keys():
            valid_geom_names.append(name)
        elif name_registration and type(self.output[name]) is not dict:
            addon_keys[name] = self.output[name]

    # Run pfset on all geom sections
    for geom_name in valid_geom_names:
        self.run.Geom[geom_name].pfset(flat_map=self.output[geom_name])

    # Handle names
    if name_registration:
        names_to_set = addon_keys
        for geom_name in valid_geom_names:
            if geom_name in self.name_registration.keys():
                for prop_name in self.name_registration[geom_name]:
                    if prop_name not in names_to_set.keys():
                        names_to_set[prop_name] = []
                    names_to_set[prop_name].append(geom_name)
        self.run.pfset(flat_map=names_to_set)

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.assign"><code class="name flex">
<span>def <span class="ident">assign</span></span>(<span>self, old=None, new=None, mapping=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to assigning subsurface properties of one unit to another</p>
<h2 id="args">Args</h2>
<p>old=None (str): Source unit with existing parameters
new=None (str): Target unit to which the parameters
from old will be mapped
mapping=None (dict): Dictionary that includes the old units as keys
and new units as values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign(self, old=None, new=None, mapping=None):
    &#34;&#34;&#34;Method to assigning subsurface properties of one unit to another

    Args:
        old=None (str): Source unit with existing parameters
        new=None (str): Target unit to which the parameters
                        from old will be mapped
        mapping=None (dict): Dictionary that includes the old units as keys
            and new units as values.
    &#34;&#34;&#34;
    # assigning subsurface properties of one unit to another
    if isinstance(new, list):
        for item in new:
            self.assign(old, item)

    elif old != new:
        data = self.output[old]
        self.output[new] = data

    if mapping is not None:
        for old, new in mapping.items():
            self.assign(old, new)

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.get_table"><code class="name flex">
<span>def <span class="ident">get_table</span></span>(<span>self, props_in_header=True, column_separator='
')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to convert loaded subsurface properties into a table</p>
<h2 id="args">Args</h2>
<p>props_in_header=True (bool): Defaults to returning a table with
property values at the top of each column
column_separator='
' (str): Defaults to returning a table that
is space-delimited.</p>
<h2 id="returns">Returns</h2>
<p>text block of table of subsurface units and parameter values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_table(self, props_in_header=True, column_separator=&#39;  &#39;):
    &#34;&#34;&#34;Method to convert loaded subsurface properties into a table

    Args:
        props_in_header=True (bool): Defaults to returning a table with
            property values at the top of each column
        column_separator=&#39;  &#39; (str): Defaults to returning a table that
            is space-delimited.

    Returns:
        text block of table of subsurface units and parameter values
    &#34;&#34;&#34;
    entries = []
    prop_set = set()
    prop_sizes = {&#39;key&#39;: 0}
    geom_sizes = {&#39;key&#39;: 0}

    # Fill entries headers
    for geo_name, props in self.output.items():
        if not isinstance(props, dict):
            continue
        elif not hasattr(self.run.Geom, geo_name):
            continue

        entry = {
            &#39;key&#39;: geo_name,
        }
        prop_sizes[&#39;key&#39;] = max(prop_sizes[&#39;key&#39;], len(geo_name))
        geom_sizes[geo_name] = len(geo_name)
        for prop in props:
            if prop in self.pfkey_to_alias:
                alias = self.pfkey_to_alias[prop]
                value = str(props[prop])
                size = len(value)
                entry[alias] = value
                prop_set.add(alias)

                # Find bigger size for geom
                geom_sizes[geo_name] = max(geom_sizes[geo_name], size)

                # Find bigger size for props
                if alias not in prop_sizes:
                    prop_sizes[alias] = max(size, len(alias))
                else:
                    prop_sizes[alias] = max(prop_sizes[alias], size)

                geom_sizes[&#39;key&#39;] = max(geom_sizes[&#39;key&#39;], len(alias))

        entries.append(entry)

    # Figure out orientation
    prop_header_width = 0
    for alias in prop_sizes:
        prop_header_width += prop_sizes[alias] + 2

    geom_header_width = 0
    for geom_name in geom_sizes:
        geom_header_width += geom_sizes[geom_name] + 2

    # Build table
    table_lines = []
    header_keys = []
    if props_in_header:
        sizes = prop_sizes
        # Create table using props as header
        line = []
        for prop in sizes:
            header_keys.append(prop)
            width = sizes[prop]
            line.append(prop.ljust(width))

        # Add header
        table_lines.append(column_separator.join(line))

        # Add content
        for entry in entries:
            line = []
            for key in header_keys:
                value = entry[key] if key in entry else &#39;-&#39;
                width = sizes[key]
                line.append(value.ljust(width))
            table_lines.append(column_separator.join(line))

    else:
        sizes = geom_sizes
        # Create table using geom name as header
        line = []
        for geom in sizes:
            header_keys.append(geom)
            width = sizes[geom]
            line.append(geom.ljust(width))

        # Add header
        table_lines.append(column_separator.join(line))

        # Add content
        for prop in prop_set:
            line = []
            for key in header_keys:
                if key == &#39;key&#39;:
                    width = sizes[key]
                    line.append(prop.ljust(width))
                    continue

                for entry in entries:
                    if entry[&#39;key&#39;] != key:
                        continue
                    value = entry[prop] if prop in entry else &#39;-&#39;
                    width = sizes[key]
                    line.append(value.ljust(width))

            table_lines.append(column_separator.join(line))

    return &#39;\n&#39;.join(table_lines)</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.load_csv_file"><code class="name flex">
<span>def <span class="ident">load_csv_file</span></span>(<span>self, tableFile, encoding='utf-8-sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to load a .csv file of a table of subsurface parameters</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tableFile</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the input .csv file.</dd>
</dl>
<p>encoding='utf-8-sig': encoding of input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_csv_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
    &#34;&#34;&#34;Method to load a .csv file of a table of subsurface parameters

    Args:
        tableFile (str): Path to the input .csv file.
        encoding=&#39;utf-8-sig&#39;: encoding of input file.
    &#34;&#34;&#34;
    with open(get_absolute_path(tableFile), &#39;r&#39;,
              encoding=encoding) as csv_file:
        data_line = False
        for line in csv_file:
            tokens = _csv_line_tokenizer(line)
            if data_line:
                self._process_data_line(tokens)
            else:
                data_line = self._process_first_line(tokens)
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.load_default_properties"><code class="name flex">
<span>def <span class="ident">load_default_properties</span></span>(<span>self, database='conus_1')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to load one of several default property databases.</p>
<h2 id="args">Args</h2>
<dl>
<dt>database='conus_1': default database - options are:</dt>
<dt>'conus_1': soil/rock properties from Maxwell and Condon (2016)</dt>
<dt>'washita': soil/rock properties from Little Washita script</dt>
<dt>'freeze_cherry': soil/rock properties from Freeze and Cherry (1979)</dt>
<dt><strong><code>Note</code></strong></dt>
<dd>Freeze and Cherry only has permeability and porosity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_default_properties(self, database=&#39;conus_1&#39;):
    &#34;&#34;&#34;Method to load one of several default property databases.

    Args:
       database=&#39;conus_1&#39;: default database - options are:
       &#39;conus_1&#39;: soil/rock properties from Maxwell and Condon (2016)
       &#39;washita&#39;: soil/rock properties from Little Washita script
       &#39;freeze_cherry&#39;: soil/rock properties from Freeze and Cherry (1979)
       Note: Freeze and Cherry only has permeability and porosity
    &#34;&#34;&#34;
    database_file = &#39;ref/subsurface_&#39; + database + &#39;.txt&#39;

    default_prop_file = os.path.join(
        os.path.dirname(__file__), database_file)

    if exists(default_prop_file):
        self.load_txt_file(default_prop_file)
        print(&#39;#&#39;*80)
        print(&#39;# Loaded database:&#39;)
        for item in self.table_comments:
            print(item)
        print(&#39;#&#39; * 80)
    else:
        print(&#39;#&#39; * 80)
        print(f&#39;# {database} database not found. Available databases include:&#39;)
        for root, dirs, files in os.walk(os.path.dirname(__file__) + &#39;/ref/&#39;):
            for name in files:
                if name.startswith(&#39;subsurface&#39;):
                    print(f&#39;# - {name} (use argument &#39;
                          f&#39;&#34;{name[len(&#34;subsurface_&#34;):-len(&#34;.txt&#34;)]}&#34;)&#39;)
        print(&#39;#&#39; * 80)


    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_content"><code class="name flex">
<span>def <span class="ident">load_txt_content</span></span>(<span>self, txt_content)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to load an in-line text table of subsurface parameters</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>txt_content</code></strong> :&ensp;<code>str</code></dt>
<dd>In-line text string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_txt_content(self, txt_content):
    &#34;&#34;&#34;Method to load an in-line text table of subsurface parameters

    Args:
        txt_content (str): In-line text string.
    &#34;&#34;&#34;
    data_line = False
    for line in txt_content.splitlines():
        tokens = _txt_line_tokenizer(line)
        if data_line:
            self._process_data_line(tokens)
        else:
            data_line = self._process_first_line(tokens)

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_file"><code class="name flex">
<span>def <span class="ident">load_txt_file</span></span>(<span>self, tableFile, encoding='utf-8-sig')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to load a .txt file of a table of subsurface parameters</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tableFile</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the input .txt file.</dd>
</dl>
<p>encoding='utf-8-sig': encoding of input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_txt_file(self, tableFile, encoding=&#39;utf-8-sig&#39;):
    &#34;&#34;&#34;Method to load a .txt file of a table of subsurface parameters

    Args:
        tableFile (str): Path to the input .txt file.
        encoding=&#39;utf-8-sig&#39;: encoding of input file.
    &#34;&#34;&#34;
    with open(get_absolute_path(tableFile), &#39;r&#39;,
              encoding=encoding) as txt_file:
        data_line = False
        for line in txt_file:
            tokens = _txt_line_tokenizer(line)
            if data_line:
                self._process_data_line(tokens)
            else:
                data_line = self._process_first_line(tokens)

    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to print subsurface properties in hierarchical format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self):
    &#34;&#34;&#34;Method to print subsurface properties in hierarchical format
    &#34;&#34;&#34;
    output_to_print = {&#39;Geom&#39;: {}}
    valid_geom_names = []
    for geom_name in self.output:
        if hasattr(self.run.Geom, geom_name):
            valid_geom_names.append(geom_name)

    for geom_name in valid_geom_names:
        if hasattr(self.name_registration, geom_name):
            for prop_name in self.name_registration[geom_name]:
                if not hasattr(output_to_print, prop_name):
                    output_to_print[prop_name] = []
                output_to_print[prop_name].append(geom_name)

    for geom_name in valid_geom_names:
        output_to_print[&#39;Geom&#39;][geom_name] = self.output[geom_name]

    print(yaml.dump(sort_dict(output_to_print), Dumper=NoAliasDumper))
    return self</code></pre>
</details>
</dd>
<dt id="parflow.tools.builders.SubsurfacePropertiesBuilder.print_as_table"><code class="name flex">
<span>def <span class="ident">print_as_table</span></span>(<span>self, props_in_header=True, column_separator='
')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to print the table returned from the get_table method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_as_table(self, props_in_header=True, column_separator=&#39;  &#39;):
    &#34;&#34;&#34;Method to print the table returned from the get_table method
    &#34;&#34;&#34;
    print(self.get_table(props_in_header, column_separator))
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="parflow.tools" href="index.html">parflow.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parflow.tools.builders.get_file_extension" href="#parflow.tools.builders.get_file_extension">get_file_extension</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="parflow.tools.builders.DomainBuilder" href="#parflow.tools.builders.DomainBuilder">DomainBuilder</a></code></h4>
<ul class="">
<li><code><a title="parflow.tools.builders.DomainBuilder.box_domain" href="#parflow.tools.builders.DomainBuilder.box_domain">box_domain</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.clm" href="#parflow.tools.builders.DomainBuilder.clm">clm</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.fully_saturated" href="#parflow.tools.builders.DomainBuilder.fully_saturated">fully_saturated</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.homogeneous_subsurface" href="#parflow.tools.builders.DomainBuilder.homogeneous_subsurface">homogeneous_subsurface</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.ic_pressure" href="#parflow.tools.builders.DomainBuilder.ic_pressure">ic_pressure</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.no_contaminants" href="#parflow.tools.builders.DomainBuilder.no_contaminants">no_contaminants</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.no_wells" href="#parflow.tools.builders.DomainBuilder.no_wells">no_wells</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.slopes_mannings" href="#parflow.tools.builders.DomainBuilder.slopes_mannings">slopes_mannings</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.spinup_timing" href="#parflow.tools.builders.DomainBuilder.spinup_timing">spinup_timing</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.variably_saturated" href="#parflow.tools.builders.DomainBuilder.variably_saturated">variably_saturated</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.water" href="#parflow.tools.builders.DomainBuilder.water">water</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.well" href="#parflow.tools.builders.DomainBuilder.well">well</a></code></li>
<li><code><a title="parflow.tools.builders.DomainBuilder.zero_flux" href="#parflow.tools.builders.DomainBuilder.zero_flux">zero_flux</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parflow.tools.builders.NoAliasDumper" href="#parflow.tools.builders.NoAliasDumper">NoAliasDumper</a></code></h4>
<ul class="">
<li><code><a title="parflow.tools.builders.NoAliasDumper.ignore_aliases" href="#parflow.tools.builders.NoAliasDumper.ignore_aliases">ignore_aliases</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parflow.tools.builders.SolidFileBuilder" href="#parflow.tools.builders.SolidFileBuilder">SolidFileBuilder</a></code></h4>
<ul class="two-column">
<li><code><a title="parflow.tools.builders.SolidFileBuilder.bottom" href="#parflow.tools.builders.SolidFileBuilder.bottom">bottom</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.bottom_ids" href="#parflow.tools.builders.SolidFileBuilder.bottom_ids">bottom_ids</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.for_key" href="#parflow.tools.builders.SolidFileBuilder.for_key">for_key</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.mask" href="#parflow.tools.builders.SolidFileBuilder.mask">mask</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.side" href="#parflow.tools.builders.SolidFileBuilder.side">side</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.side_ids" href="#parflow.tools.builders.SolidFileBuilder.side_ids">side_ids</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.top" href="#parflow.tools.builders.SolidFileBuilder.top">top</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.top_ids" href="#parflow.tools.builders.SolidFileBuilder.top_ids">top_ids</a></code></li>
<li><code><a title="parflow.tools.builders.SolidFileBuilder.write" href="#parflow.tools.builders.SolidFileBuilder.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder" href="#parflow.tools.builders.SubsurfacePropertiesBuilder">SubsurfacePropertiesBuilder</a></code></h4>
<ul class="">
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.apply" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.apply">apply</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.assign" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.assign">assign</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.get_table" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.get_table">get_table</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.load_csv_file" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.load_csv_file">load_csv_file</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.load_default_properties" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.load_default_properties">load_default_properties</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_content" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_content">load_txt_content</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_file" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.load_txt_file">load_txt_file</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.print" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.print">print</a></code></li>
<li><code><a title="parflow.tools.builders.SubsurfacePropertiesBuilder.print_as_table" href="#parflow.tools.builders.SubsurfacePropertiesBuilder.print_as_table">print_as_table</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>